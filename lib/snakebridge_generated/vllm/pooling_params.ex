# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm
# Python class: PoolingParams

defmodule Vllm.PoolingParams do
  @moduledoc """
  API parameters for pooling models.

  Attributes:
      truncate_prompt_tokens: Controls prompt truncation.
          Set to -1 to use the model's default truncation size.
          Set to k to keep only the last k tokens (left truncation).
          Set to None to disable truncation.
      dimensions: Reduce the dimensions of embeddings
          if model support matryoshka representation.
      normalize: Deprecated, please use use_activation instead.
      softmax: Deprecated, please use use_activation instead.
      activation: Deprecated, please use use_activation instead.
      use_activation: Whether to apply activation function to
          the classification outputs.
  """
  def __snakebridge_python_name__, do: "vllm"
  def __snakebridge_python_class__, do: "PoolingParams"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `model_config` (term() | nil default: None)

  ## Returns

  - `nil`
  """
  @spec _merge_default_parameters(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _merge_default_parameters(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :_merge_default_parameters, [] ++ List.wrap(args), opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `model_config` (term() | nil)

  ## Returns

  - `term()`
  """
  @spec _set_default_parameters(SnakeBridge.Ref.t(), term() | nil, keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _set_default_parameters(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_set_default_parameters, [model_config], opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `pooler_config` (term())
  - `valid_parameters` (list(String.t()))

  ## Returns

  - `term()`
  """
  @spec _verify_step_pooling(SnakeBridge.Ref.t(), term(), list(String.t()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _verify_step_pooling(ref, pooler_config, valid_parameters, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_verify_step_pooling,
      [pooler_config, valid_parameters],
      opts
    )
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Returns

  - `term()`
  """
  @spec _verify_valid_parameters(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _verify_valid_parameters(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_valid_parameters, [], opts)
  end

  @doc """
  Returns a deep copy of the PoolingParams instance.

  ## Returns

  - `Vllm.PoolingParamsClass.t()`
  """
  @spec clone(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, Vllm.PoolingParamsClass.t()} | {:error, Snakepit.Error.t()}
  def clone(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :clone, [], opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `task` (term())
  - `model_config` (term() | nil default: None)

  ## Returns

  - `nil`
  """
  @spec verify(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify(ref, task, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :verify, [task] ++ List.wrap(args), opts)
  end

  @spec activation(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def activation(ref) do
    SnakeBridge.Runtime.get_attr(ref, :activation)
  end

  @spec all_parameters(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_parameters(ref) do
    SnakeBridge.Runtime.get_attr(ref, :all_parameters)
  end

  @spec dimensions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dimensions(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dimensions)
  end

  @spec extra_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def extra_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :extra_kwargs)
  end

  @spec normalize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def normalize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :normalize)
  end

  @spec output_kind(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_kind(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_kind)
  end

  @spec requires_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def requires_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :requires_token_ids)
  end

  @spec returned_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def returned_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :returned_token_ids)
  end

  @spec skip_reading_prefix_cache(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_reading_prefix_cache(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_reading_prefix_cache)
  end

  @spec softmax(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def softmax(ref) do
    SnakeBridge.Runtime.get_attr(ref, :softmax)
  end

  @spec step_tag_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def step_tag_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :step_tag_id)
  end

  @spec task(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def task(ref) do
    SnakeBridge.Runtime.get_attr(ref, :task)
  end

  @spec truncate_prompt_tokens(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def truncate_prompt_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :truncate_prompt_tokens)
  end

  @spec use_activation(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_activation(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_activation)
  end

  @spec valid_parameters(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def valid_parameters(ref) do
    SnakeBridge.Runtime.get_attr(ref, :valid_parameters)
  end
end
