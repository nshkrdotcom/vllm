# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.distributed
# Python class: StatelessProcessGroup

defmodule Vllm.Distributed.StatelessProcessGroup do
  @moduledoc """
  A dataclass to hold a metadata store, and the rank, world_size of the

  group. Only use it to communicate metadata between processes.
  For data-plane communication, create NCCL-related objects.
  """
  def __snakebridge_python_name__, do: "vllm.distributed"
  def __snakebridge_python_class__, do: "StatelessProcessGroup"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `rank` (integer())
  - `world_size` (integer())
  - `store` (term())
  - `socket` (term())
  - `data_expiration_seconds` (integer() default: 3600)
  - `send_dst_counter` (%{optional(integer()) => integer()} default: <factory>)
  - `recv_src_counter` (%{optional(integer()) => integer()} default: <factory>)
  - `broadcast_send_counter` (integer() default: 0)
  - `broadcast_recv_src_counter` (%{optional(integer()) => integer()} default: <factory>)
  - `entries` (term() default: <factory>)
  """
  @spec new(integer(), integer(), term(), term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(rank, world_size, store, socket, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [rank, world_size, store, socket] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  All gather an object from all ranks.

  ## Parameters

  - `obj` (term())

  ## Returns

  - `list(term())`
  """
  @spec all_gather_obj(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, list(term())} | {:error, Snakepit.Error.t()}
  def all_gather_obj(ref, obj, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :all_gather_obj, [obj], opts)
  end

  @doc """
  A robust barrier to synchronize all ranks.

  Uses a multi-phase approach to ensure all processes reach the barrier
  before proceeding:

  1. Each process signals it has reached the barrier

  2. Each process signals that it has confirmed the arrival of all other
  ranks.

  3. Rank 0 waits for all other ranks to signal their departure to ensure
  that all ranks have departed the barrier first.

  ## Parameters

  - `timeout` - Maximum time in seconds to wait for each phase (in seconds)

  ## Raises

  - `RuntimeError` - If coordination fails or times out

  ## Returns

  - `term()`
  """
  @spec barrier(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def barrier(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :barrier, [] ++ List.wrap(args), opts)
  end

  @doc """
  Broadcast an object from a source rank to all other ranks.

  It does not clean up after all ranks have received the object.
  Use it for limited times, e.g., for initialization.

  ## Parameters

  - `obj` (term())
  - `src` (integer())

  ## Returns

  - `term()`
  """
  @spec broadcast_obj(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def broadcast_obj(ref, obj, src, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :broadcast_obj, [obj, src], opts)
  end

  @doc """
  A replacement for `torch.distributed.init_process_group` that does not

  pollute the global state.

  If we have process A and process B called `torch.distributed.init_process_group`
  to form a group, and then we want to form another group with process A, B, C,
  D, it is not possible in PyTorch, because process A and process B have already
  formed a group, and process C and process D cannot join that group. This
  function is a workaround for this issue.

  `torch.distributed.init_process_group` is a global call, while this function
  is a stateless call. It will return a `StatelessProcessGroup` object that can be
  used for exchanging metadata. With this function, process A and process B
  can call `StatelessProcessGroup.create` to form a group, and then process A, B,
  C, and D can call `StatelessProcessGroup.create` to form another group.

  ## Parameters

  - `host` (String.t())
  - `port` (integer())
  - `rank` (integer())
  - `world_size` (integer())
  - `data_expiration_seconds` (integer() default: 3600)
  - `store_timeout` (integer() default: 300)

  ## Returns

  - `term()`
  """
  @spec create(
          SnakeBridge.Ref.t(),
          String.t(),
          integer(),
          integer(),
          integer(),
          list(term()),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def create(ref, host, port, rank, world_size, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :create,
      [host, port, rank, world_size] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Expire data that is older than `data_expiration_seconds` seconds.

  ## Returns

  - `term()`
  """
  @spec expire_data(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def expire_data(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :expire_data, [], opts)
  end

  @doc """
  Receive an object from a source rank.

  ## Parameters

  - `src` (integer())

  ## Returns

  - `term()`
  """
  @spec recv_obj(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def recv_obj(ref, src, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :recv_obj, [src], opts)
  end

  @doc """
  Send an object to a destination rank.

  ## Parameters

  - `obj` (term())
  - `dst` (integer())

  ## Returns

  - `term()`
  """
  @spec send_obj(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def send_obj(ref, obj, dst, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :send_obj, [obj, dst], opts)
  end

  @spec broadcast_send_counter(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def broadcast_send_counter(ref) do
    SnakeBridge.Runtime.get_attr(ref, :broadcast_send_counter)
  end

  @spec data_expiration_seconds(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_expiration_seconds(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_expiration_seconds)
  end
end
