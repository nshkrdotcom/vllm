# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.distributed
# Python class: DeviceCommunicatorBase

defmodule Vllm.Distributed.DeviceCommunicatorBase do
  @moduledoc """
  Base class for device-specific communicator.

  It can use the `cpu_group` to initialize the communicator.
  If the device has PyTorch integration (PyTorch can recognize its
  communication backend), the `device_group` will also be given.
  """
  def __snakebridge_python_name__, do: "vllm.distributed"
  def __snakebridge_python_class__, do: "DeviceCommunicatorBase"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `cpu_group` (term())
  - `device` (term() default: None)
  - `device_group` (term() default: None)
  - `unique_name` (String.t() default: '')
  """
  @spec new(term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(cpu_group, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [cpu_group] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.all_gather`.

  ## Parameters

  - `input_` (term())
  - `dim` (integer() default: -1)

  ## Returns

  - `term()`
  """
  @spec all_gather(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_gather(ref, input_, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :all_gather, [input_] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.all_gatherv`.

  ## Parameters

  - `input_` (term())
  - `dim` (integer() default: 0)
  - `sizes` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec all_gatherv(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_gatherv(ref, input_, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :all_gatherv, [input_] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.all_reduce`.

  ## Parameters

  - `input_` (term())

  ## Returns

  - `term()`
  """
  @spec all_reduce(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_reduce(ref, input_, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :all_reduce, [input_], opts)
  end

  @doc """
  Combine the hidden states and router logits from the appropriate device.

  This is a no-op in the base class.

  ## Parameters

  - `hidden_states` (term())
  - `is_sequence_parallel` (boolean() default: False)

  ## Returns

  - `term()`
  """
  @spec combine(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def combine(ref, hidden_states, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :combine, [hidden_states] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.destroy`.

  ## Returns

  - `term()`
  """
  @spec destroy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def destroy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :destroy, [], opts)
  end

  @doc """
  Dispatch the hidden states and router logits to the appropriate device.

  This is a no-op in the base class.

  ## Parameters

  - `hidden_states` (term())
  - `router_logits` (term())
  - `is_sequence_parallel` (boolean() default: False)
  - `extra_tensors` (term() default: None)

  ## Returns

  - `{term(), term()}`
  """
  @spec dispatch(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, {term(), term()}} | {:error, Snakepit.Error.t()}
  def dispatch(ref, hidden_states, router_logits, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :dispatch,
      [hidden_states, router_logits] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  NOTE: We assume that the input tensor is on the same device across

  all the ranks.
  NOTE: `dst` is the local rank of the destination rank.

  ## Parameters

  - `input_` (term())
  - `dst` (integer() default: 0)
  - `dim` (integer() default: -1)

  ## Returns

  - `term()`
  """
  @spec gather(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def gather(ref, input_, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :gather, [input_] ++ List.wrap(args), opts)
  end

  @doc """
  Prepare the communication buffer for the model.

  ## Parameters

  - `model` (term())

  ## Returns

  - `nil`
  """
  @spec prepare_communication_buffer_for_model(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def prepare_communication_buffer_for_model(ref, model, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :prepare_communication_buffer_for_model, [model], opts)
  end

  @doc """
  Receives a tensor from the source rank.

  ## Parameters

  - `size` (term())
  - `dtype` (term())
  - `src` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec recv(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def recv(ref, size, dtype, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :recv, [size, dtype] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.reduce_scatter`.

  ## Parameters

  - `input_` (term())
  - `dim` (integer() default: -1)

  ## Returns

  - `term()`
  """
  @spec reduce_scatter(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def reduce_scatter(ref, input_, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :reduce_scatter, [input_] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `DeviceCommunicatorBase.reduce_scatterv`.

  ## Parameters

  - `input_` (term())
  - `dim` (integer() default: -1)
  - `sizes` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec reduce_scatterv(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def reduce_scatterv(ref, input_, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :reduce_scatterv, [input_] ++ List.wrap(args), opts)
  end

  @doc """
  Sends a tensor to the destination rank in a blocking way

  ## Parameters

  - `tensor` (term())
  - `dst` (term() default: None)

  ## Returns

  - `nil`
  """
  @spec send(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def send(ref, tensor, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :send, [tensor] ++ List.wrap(args), opts)
  end
end
