# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm
# Python class: SamplingParams

defmodule Vllm.SamplingParams do
  @moduledoc """
  Sampling parameters for text generation.

  Overall, we follow the sampling parameters from the OpenAI text completion
  API (https://platform.openai.com/docs/api-reference/completions/create).
  In addition, we support beam search, which is not supported by OpenAI.
  """
  def __snakebridge_python_name__, do: "vllm"
  def __snakebridge_python_class__, do: "SamplingParams"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Validate and convert input to msgspec.Struct instance.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec _validate_msgspec(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_msgspec(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_msgspec, [value], opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Returns

  - `nil`
  """
  @spec _verify_args(SnakeBridge.Ref.t(), keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_args(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_args, [], opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Returns

  - `nil`
  """
  @spec _verify_greedy_sampling(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_greedy_sampling(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_greedy_sampling, [], opts)
  end

  @doc """
  Deep copy, but maybe not the LogitsProcessor objects.

  LogitsProcessor objects may contain an arbitrary, nontrivial amount of
  data that is expensive to copy. However, if not copied, the processor
  needs to support parallel decoding for multiple sequences
  See https://github.com/vllm-project/vllm/issues/3087

  If skip_clone is True, uses shallow copy instead of deep copy.

  ## Returns

  - `Vllm.SamplingParamsClass.t()`
  """
  @spec clone(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, Vllm.SamplingParamsClass.t()} | {:error, Snakepit.Error.t()}
  def clone(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :clone, [], opts)
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `n` (term() default: 1)
  - `presence_penalty` (term() default: 0.0)
  - `frequency_penalty` (term() default: 0.0)
  - `repetition_penalty` (term() default: 1.0)
  - `temperature` (term() default: 1.0)
  - `top_p` (term() default: 1.0)
  - `top_k` (integer() default: 0)
  - `min_p` (float() default: 0.0)
  - `seed` (term() default: None)
  - `stop` (term() default: None)
  - `stop_token_ids` (term() default: None)
  - `bad_words` (term() default: None)
  - `include_stop_str_in_output` (boolean() default: False)
  - `ignore_eos` (boolean() default: False)
  - `max_tokens` (term() default: 16)
  - `min_tokens` (integer() default: 0)
  - `logprobs` (term() default: None)
  - `prompt_logprobs` (term() default: None)
  - `detokenize` (boolean() default: True)
  - `skip_special_tokens` (boolean() default: True)
  - `spaces_between_special_tokens` (boolean() default: True)
  - `logits_processors` (term() default: None)
  - `truncate_prompt_tokens` (integer() | nil default: None)
  - `output_kind` (Vllm.SamplingParams.RequestOutputKind.t() default: <RequestOutputKind.CUMULATIVE: 0>)
  - `structured_outputs` (term() default: None)
  - `logit_bias` (term() default: None)
  - `allowed_token_ids` (term() default: None)
  - `extra_args` (term() default: None)
  - `skip_clone` (boolean() default: False)

  ## Returns

  - `Vllm.SamplingParamsClass.t()`
  """
  @spec from_optional(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, Vllm.SamplingParamsClass.t()} | {:error, Snakepit.Error.t()}
  def from_optional(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :from_optional, [] ++ List.wrap(args), opts)
  end

  @doc """
  Update if there are non-default values from generation_config

  ## Parameters

  - `generation_config` (%{optional(String.t()) => term()})
  - `model_eos_token_id` (term() default: None)

  ## Returns

  - `nil`
  """
  @spec update_from_generation_config(
          SnakeBridge.Ref.t(),
          %{optional(String.t()) => term()},
          list(term()),
          keyword()
        ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def update_from_generation_config(ref, generation_config, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :update_from_generation_config,
      [generation_config] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  vLLM: a high-throughput and memory-efficient inference engine for LLMs

  ## Parameters

  - `tokenizer` (term())

  ## Returns

  - `nil`
  """
  @spec update_from_tokenizer(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def update_from_tokenizer(ref, tokenizer, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :update_from_tokenizer, [tokenizer], opts)
  end

  @spec _all_stop_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _all_stop_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_all_stop_token_ids)
  end

  @spec _bad_words_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _bad_words_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_bad_words_token_ids)
  end

  @spec all_stop_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_stop_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :all_stop_token_ids)
  end

  @spec allowed_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def allowed_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :allowed_token_ids)
  end

  @spec bad_words(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bad_words(ref) do
    SnakeBridge.Runtime.get_attr(ref, :bad_words)
  end

  @spec bad_words_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bad_words_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :bad_words_token_ids)
  end

  @spec detokenize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def detokenize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :detokenize)
  end

  @spec extra_args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def extra_args(ref) do
    SnakeBridge.Runtime.get_attr(ref, :extra_args)
  end

  @spec flat_logprobs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def flat_logprobs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :flat_logprobs)
  end

  @spec frequency_penalty(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def frequency_penalty(ref) do
    SnakeBridge.Runtime.get_attr(ref, :frequency_penalty)
  end

  @spec ignore_eos(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ignore_eos(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ignore_eos)
  end

  @spec include_stop_str_in_output(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def include_stop_str_in_output(ref) do
    SnakeBridge.Runtime.get_attr(ref, :include_stop_str_in_output)
  end

  @spec logit_bias(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logit_bias(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logit_bias)
  end

  @spec logits_processors(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logits_processors(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logits_processors)
  end

  @spec logprobs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logprobs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logprobs)
  end

  @spec max_tokens(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_tokens)
  end

  @spec min_p(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def min_p(ref) do
    SnakeBridge.Runtime.get_attr(ref, :min_p)
  end

  @spec min_tokens(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def min_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :min_tokens)
  end

  @spec n(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def n(ref) do
    SnakeBridge.Runtime.get_attr(ref, :n)
  end

  @spec output_kind(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_kind(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_kind)
  end

  @spec output_text_buffer_length(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_text_buffer_length(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_text_buffer_length)
  end

  @spec presence_penalty(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def presence_penalty(ref) do
    SnakeBridge.Runtime.get_attr(ref, :presence_penalty)
  end

  @spec prompt_logprobs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def prompt_logprobs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :prompt_logprobs)
  end

  @spec repetition_penalty(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def repetition_penalty(ref) do
    SnakeBridge.Runtime.get_attr(ref, :repetition_penalty)
  end

  @spec sampling_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def sampling_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :sampling_type)
  end

  @spec seed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def seed(ref) do
    SnakeBridge.Runtime.get_attr(ref, :seed)
  end

  @spec skip_clone(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_clone(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_clone)
  end

  @spec skip_reading_prefix_cache(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_reading_prefix_cache(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_reading_prefix_cache)
  end

  @spec skip_special_tokens(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_special_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_special_tokens)
  end

  @spec spaces_between_special_tokens(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def spaces_between_special_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :spaces_between_special_tokens)
  end

  @spec stop(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stop(ref) do
    SnakeBridge.Runtime.get_attr(ref, :stop)
  end

  @spec stop_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stop_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :stop_token_ids)
  end

  @spec structured_outputs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def structured_outputs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :structured_outputs)
  end

  @spec temperature(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def temperature(ref) do
    SnakeBridge.Runtime.get_attr(ref, :temperature)
  end

  @spec top_k(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def top_k(ref) do
    SnakeBridge.Runtime.get_attr(ref, :top_k)
  end

  @spec top_p(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def top_p(ref) do
    SnakeBridge.Runtime.get_attr(ref, :top_p)
  end

  @spec truncate_prompt_tokens(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def truncate_prompt_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :truncate_prompt_tokens)
  end
end
