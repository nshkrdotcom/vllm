# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.beam_search
# Python class: BeamSearchSequence

defmodule Vllm.BeamSearch.BeamSearchSequence do
  @moduledoc """
  A sequence for beam search.

  It keeps track of the tokens and the log probability of the sequence.
  The text field is optional and will only be filled when the sequence is
  about to be returned to the user.
  """
  def __snakebridge_python_name__, do: "vllm.beam_search"
  def __snakebridge_python_class__, do: "BeamSearchSequence"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `tokens` (list(integer()))
  - `logprobs` (list(%{optional(integer()) => Vllm.Logprobs.Logprob.t()}))
  - `lora_request` (term() default: None)
  - `cum_logprob` (float() default: 0.0)
  - `text` (term() default: None)
  - `finish_reason` (term() default: None)
  - `stop_reason` (term() default: None)
  - `multi_modal_data` (term() | nil default: None)
  - `mm_processor_kwargs` (term() default: None)
  """
  @spec new(
          list(integer()),
          list(%{optional(integer()) => Vllm.Logprobs.Logprob.t()}),
          list(term()),
          keyword()
        ) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(tokens, logprobs, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [tokens, logprobs] ++ List.wrap(args),
      opts
    )
  end

  @spec cum_logprob(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cum_logprob(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cum_logprob)
  end

  @spec finish_reason(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def finish_reason(ref) do
    SnakeBridge.Runtime.get_attr(ref, :finish_reason)
  end

  @spec lora_request(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lora_request(ref) do
    SnakeBridge.Runtime.get_attr(ref, :lora_request)
  end

  @spec mm_processor_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_kwargs)
  end

  @spec multi_modal_data(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def multi_modal_data(ref) do
    SnakeBridge.Runtime.get_attr(ref, :multi_modal_data)
  end

  @spec stop_reason(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stop_reason(ref) do
    SnakeBridge.Runtime.get_attr(ref, :stop_reason)
  end

  @spec text(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def text(ref) do
    SnakeBridge.Runtime.get_attr(ref, :text)
  end
end
