# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.multimodal
# Python class: MultiModalKwargsItems

defmodule Vllm.Multimodal.MultiModalKwargsItems do
  @moduledoc """
  A dictionary of

  [`MultiModalKwargsItem`][vllm.multimodal.inputs.MultiModalKwargsItem]s
  by modality.
  """
  def __snakebridge_python_name__, do: "vllm.multimodal"
  def __snakebridge_python_class__, do: "MultiModalKwargsItems"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `dict` (term() default: None)
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  D.clear() -> None.  Remove all items from D.

  ## Returns

  - `term()`
  """
  @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def clear(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
  end

  @doc """
  Python method `MultiModalKwargsItems.copy`.

  ## Returns

  - `term()`
  """
  @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
  end

  @doc """
  Python method `MultiModalKwargsItems.from_hf_inputs`.

  ## Parameters

  - `hf_inputs` (term())
  - `config_by_key` (term())

  ## Returns

  - `term()`
  """
  @spec from_hf_inputs(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_hf_inputs(ref, hf_inputs, config_by_key, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_hf_inputs, [hf_inputs, config_by_key], opts)
  end

  @doc """
  Python method `MultiModalKwargsItems.from_seq`.

  ## Parameters

  - `items` (term())

  ## Returns

  - `term()`
  """
  @spec from_seq(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_seq(ref, items, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_seq, [items], opts)
  end

  @doc """
  Python method `MultiModalKwargsItems.fromkeys`.

  ## Parameters

  - `iterable` (term())
  - `value` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def fromkeys(ref, iterable, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
  end

  @doc """
  D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

  ## Parameters

  - `key` (term())
  - `default` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
  end

  @doc """
  Construct a dictionary of keyword arguments to pass to the model.

  ## Parameters

  - `device` (((term() | String.t()) | integer()) | nil keyword-only default: None)
  - `pin_memory` (boolean() keyword-only default: False)

  ## Returns

  - `%{
    optional(String.t()) =>
      ((list(((list(term()) | list(term())) | term()) | {term(), term()}) | list(term())) | term())
      | {term(), term()}
  }`
  """
  @spec get_data(SnakeBridge.Ref.t(), keyword()) ::
          {:ok,
           %{
             optional(String.t()) =>
               ((list(((list(term()) | list(term())) | term()) | {term(), term()}) | list(term()))
                | term())
               | {term(), term()}
           }}
          | {:error, Snakepit.Error.t()}
  def get_data(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_data, [], opts)
  end

  @doc """
  D.items() -> a set-like object providing a view on D's items

  ## Returns

  - `term()`
  """
  @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def items(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :items, [], opts)
  end

  @doc """
  D.keys() -> a set-like object providing a view on D's keys

  ## Returns

  - `term()`
  """
  @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def keys(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
  end

  @doc """
  D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

  If key is not found, d is returned if given, otherwise KeyError is raised.

  ## Parameters

  - `key` (term())
  - `default` (term() default: <object object at 0x75d5e2c901c0>)

  ## Returns

  - `term()`
  """
  @spec pop(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def pop(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :pop, [key] ++ List.wrap(args), opts)
  end

  @doc """
  D.popitem() -> (k, v), remove and return some (key, value) pair

  as a 2-tuple; but raise KeyError if D is empty.

  ## Returns

  - `term()`
  """
  @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def popitem(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
  end

  @doc """
  Python method `MultiModalKwargsItems.require_data`.

  ## Returns

  - `term()`
  """
  @spec require_data(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def require_data(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :require_data, [], opts)
  end

  @doc """
  D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

  ## Parameters

  - `key` (term())
  - `default` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def setdefault(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
  end

  @doc """
  D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.

  If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
  If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
  In either case, this is followed by: for k, v in F.items(): D[k] = v

  ## Parameters

  - `other` (term() default: ())
  - `kwds` (term())

  ## Returns

  - `term()`
  """
  @spec update(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def update(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :update, [] ++ List.wrap(args), opts)
  end

  @doc """
  D.values() -> an object providing a view on D's values

  ## Returns

  - `term()`
  """
  @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def values(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :values, [], opts)
  end

  @spec __mutable_mapping__marker(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def __mutable_mapping__marker(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_MutableMapping__marker)
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end
end
