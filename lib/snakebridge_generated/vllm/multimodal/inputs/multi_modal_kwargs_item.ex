# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.multimodal.inputs
# Python class: MultiModalKwargsItem

defmodule Vllm.Multimodal.Inputs.MultiModalKwargsItem do
  @moduledoc """
  A collection of

  [`MultiModalFieldElem`][vllm.multimodal.inputs.MultiModalFieldElem]
  corresponding to a data item in
  [`MultiModalDataItems`][vllm.multimodal.parse.MultiModalDataItems].
  """
  def __snakebridge_python_name__, do: "vllm.multimodal.inputs"
  def __snakebridge_python_class__, do: "MultiModalKwargsItem"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `data` (term() default: {})
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  D.clear() -> None.  Remove all items from D.

  ## Returns

  - `term()`
  """
  @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def clear(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
  end

  @doc """
  Python method `MultiModalKwargsItem.copy`.

  ## Returns

  - `term()`
  """
  @spec copy(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :copy, [], opts)
  end

  @doc """
  Convenience class for testing.

  ## Parameters

  - `modality` (String.t())
  - `nbytes` (integer() default: 1)

  ## Returns

  - `term()`
  """
  @spec dummy(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dummy(ref, modality, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :dummy, [modality] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `MultiModalKwargsItem.from_elems`.

  ## Parameters

  - `elems` (term())

  ## Returns

  - `term()`
  """
  @spec from_elems(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_elems(ref, elems, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_elems, [elems], opts)
  end

  @doc """
  Python method `MultiModalKwargsItem.fromkeys`.

  ## Parameters

  - `iterable` (term())
  - `value` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec fromkeys(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def fromkeys(ref, iterable, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :fromkeys, [iterable] ++ List.wrap(args), opts)
  end

  @doc """
  D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

  ## Parameters

  - `key` (term())
  - `default` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec get(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get, [key] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `MultiModalKwargsItem.get_data`.

  ## Returns

  - `%{
    optional(String.t()) =>
      ((list(((list(term()) | list(term())) | term()) | {term(), term()}) | list(term())) | term())
      | {term(), term()}
  }`
  """
  @spec get_data(SnakeBridge.Ref.t(), keyword()) ::
          {:ok,
           %{
             optional(String.t()) =>
               ((list(((list(term()) | list(term())) | term()) | {term(), term()}) | list(term()))
                | term())
               | {term(), term()}
           }}
          | {:error, Snakepit.Error.t()}
  def get_data(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_data, [], opts)
  end

  @doc """
  D.items() -> a set-like object providing a view on D's items

  ## Returns

  - `term()`
  """
  @spec items(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def items(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :items, [], opts)
  end

  @doc """
  D.keys() -> a set-like object providing a view on D's keys

  ## Returns

  - `term()`
  """
  @spec keys(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def keys(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :keys, [], opts)
  end

  @doc """
  D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

  If key is not found, d is returned if given, otherwise KeyError is raised.

  ## Parameters

  - `key` (term())
  - `default` (term() default: <object object at 0x7d4dbfd781c0>)

  ## Returns

  - `term()`
  """
  @spec pop(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def pop(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :pop, [key] ++ List.wrap(args), opts)
  end

  @doc """
  D.popitem() -> (k, v), remove and return some (key, value) pair

  as a 2-tuple; but raise KeyError if D is empty.

  ## Returns

  - `term()`
  """
  @spec popitem(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def popitem(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :popitem, [], opts)
  end

  @doc """
  D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

  ## Parameters

  - `key` (term())
  - `default` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec setdefault(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def setdefault(ref, key, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :setdefault, [key] ++ List.wrap(args), opts)
  end

  @doc """
  D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.

  If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
  If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
  In either case, this is followed by: for k, v in F.items(): D[k] = v

  ## Parameters

  - `other` (term() default: ())
  - `kwds` (term())

  ## Returns

  - `term()`
  """
  @spec update(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def update(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :update, [] ++ List.wrap(args), opts)
  end

  @doc """
  D.values() -> an object providing a view on D's values

  ## Returns

  - `term()`
  """
  @spec values(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def values(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :values, [], opts)
  end

  @spec __mutable_mapping__marker(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def __mutable_mapping__marker(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_MutableMapping__marker)
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end

  @spec modality(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def modality(ref) do
    SnakeBridge.Runtime.get_attr(ref, :modality)
  end
end
