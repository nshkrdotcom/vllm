# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.multimodal.inputs
# Python class: PlaceholderRange

defmodule Vllm.Multimodal.Inputs.PlaceholderRange do
  @moduledoc """
  Placeholder location information for multi-modal data.
  """
  def __snakebridge_python_name__, do: "vllm.multimodal.inputs"
  def __snakebridge_python_class__, do: "PlaceholderRange"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `offset` (integer())
  - `length` (integer())
  - `is_embed` (term() | nil default: None)
  """
  @spec new(integer(), integer(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(offset, length, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [offset, length] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Extract the start and end indices of the embedded region in prompt.

  For example, given `PlaceholderRange(offset=2, length=5)` and
  `is_embed = [False, True, False, True, True]`, the output is
  `[(1 + offset, 1 + offset), (3 + offset, 4 + offset)]`.

  ## Returns

  - `list({integer(), integer()})`
  """
  @spec extract_embeds_range(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, list({integer(), integer()})} | {:error, Snakepit.Error.t()}
  def extract_embeds_range(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extract_embeds_range, [], opts)
  end

  @doc """
  Returns the starting and ending indices of the embeddings of encoder outputs

  in the range of [start_idx, end_idx) in the placeholders.

  For example, given:
  PlaceholderRange(offset=2, length=5, is_embed=[False, True, False, True, True])

  If start_idx=3 and end_idx=5, the output is (1, 3) because we want to get
  the second and the third embeddings from the encoder output.

  ## Parameters

  - `start_idx` (integer())
  - `end_idx` (integer())

  ## Returns

  - `{integer(), integer()}`
  """
  @spec get_embeds_indices_in_range(SnakeBridge.Ref.t(), integer(), integer(), keyword()) ::
          {:ok, {integer(), integer()}} | {:error, Snakepit.Error.t()}
  def get_embeds_indices_in_range(ref, start_idx, end_idx, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_embeds_indices_in_range, [start_idx, end_idx], opts)
  end

  @spec embeds_cumsum(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def embeds_cumsum(ref) do
    SnakeBridge.Runtime.get_attr(ref, :embeds_cumsum)
  end

  @spec get_num_embeds(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_num_embeds(ref) do
    SnakeBridge.Runtime.get_attr(ref, :get_num_embeds)
  end

  @spec is_embed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_embed(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_embed)
  end
end
