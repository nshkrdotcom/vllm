# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.multimodal
# Python class: MultiModalRegistry

defmodule Vllm.Multimodal.MultiModalRegistry do
  @moduledoc """
  A registry that dispatches data processing according to the model.
  """
  def __snakebridge_python_name__, do: "vllm.multimodal"
  def __snakebridge_python_class__, do: "MultiModalRegistry"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `MultiModalRegistry._create_processing_ctx`.

  ## Parameters

  - `model_config` (term())
  - `observability_config` (term() default: None)
  - `tokenizer` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec _create_processing_ctx(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _create_processing_ctx(ref, model_config, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :_create_processing_ctx,
      [model_config] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `MultiModalRegistry._create_processing_info`.

  ## Parameters

  - `model_config` (term())
  - `observability_config` (term() default: None)
  - `tokenizer` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec _create_processing_info(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _create_processing_info(ref, model_config, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :_create_processing_info,
      [model_config] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Extract multimodal dummy options from model config.

  Returns None if no configurable options are found, otherwise returns
  a mapping of modality names to their dummy options.

  ## Parameters

  - `model_config` (term())

  ## Returns

  - `term()`
  """
  @spec _extract_mm_options(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _extract_mm_options(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_extract_mm_options, [model_config], opts)
  end

  @doc """
  Python method `MultiModalRegistry._get_model_cls`.

  ## Parameters

  - `model_config` (term())

  ## Returns

  - `term()`
  """
  @spec _get_model_cls(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_model_cls(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_model_cls, [model_config], opts)
  end

  @doc """
  Create a multi-modal processor for a specific model and tokenizer.

  ## Parameters

  - `model_config` (term())
  - `observability_config` (term() default: None)
  - `tokenizer` (term() keyword-only default: None)
  - `cache` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec create_processor(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def create_processor(ref, model_config, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :create_processor,
      [model_config] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Create dummy data for profiling the memory usage of a model.

  The model is identified by `model_config`.

  ## Parameters

  - `model_config` (term())
  - `seq_len` (integer())
  - `mm_counts` (term() default: None)
  - `cache` (term() keyword-only default: None)
  - `observability_config` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec get_decoder_dummy_data(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_decoder_dummy_data(ref, model_config, seq_len, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :get_decoder_dummy_data,
      [model_config, seq_len] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Get the maximum length of the encoder input for encoder-decoder models.

  ## Parameters

  - `model_config` (term())

  ## Returns

  - `integer()`
  """
  @spec get_encdec_max_encoder_len(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_encdec_max_encoder_len(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_encdec_max_encoder_len, [model_config], opts)
  end

  @doc """
  Create dummy data for profiling the memory usage of a model.

  The model is identified by `model_config`.

  ## Parameters

  - `model_config` (term())
  - `seq_len` (integer())
  - `mm_counts` (term() default: None)
  - `cache` (term() keyword-only default: None)
  - `observability_config` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec get_encoder_dummy_data(SnakeBridge.Ref.t(), term(), integer(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_encoder_dummy_data(ref, model_config, seq_len, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :get_encoder_dummy_data,
      [model_config, seq_len] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Get the maximum number of tokens per data item from each modality based

  on underlying model configuration.

  ## Parameters

  - `model_config` (term())
  - `cache` (term() keyword-only default: None)
  - `profiler_limits` (term() keyword-only default: None)
  - `observability_config` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec get_max_tokens_per_item_by_modality(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_max_tokens_per_item_by_modality(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :get_max_tokens_per_item_by_modality,
      [model_config],
      opts
    )
  end

  @doc """
  Get the maximum number of multi-modal input instances for each modality

  that are allowed per prompt for a model class.

  ## Parameters

  - `model_config` (term())
  - `cache` (term() keyword-only default: None)
  - `observability_config` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec get_mm_limits_per_prompt(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_mm_limits_per_prompt(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_mm_limits_per_prompt, [model_config], opts)
  end

  @doc """
  Register a multi-modal processor to a model class. The processor

  is constructed lazily, hence a factory method should be passed.

  When the model receives multi-modal data, the provided function is
  invoked to transform the data into a dictionary of model inputs.

  ## Parameters

  - `processor` (term())
  - `info` (term() keyword-only, required)
  - `dummy_inputs` (term() keyword-only, required)

  ## Returns

  - `term()`
  """
  @spec register_processor(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def register_processor(ref, processor, opts \\ []) do
    kw_keys = opts |> Keyword.keys() |> Enum.map(&to_string/1)
    missing_kw = ["info", "dummy_inputs"] |> Enum.reject(&(&1 in kw_keys))

    if missing_kw != [] do
      raise ArgumentError,
            "Missing required keyword-only arguments: " <> Enum.join(missing_kw, ", ")
    end

    SnakeBridge.Runtime.call_method(ref, :register_processor, [processor], opts)
  end

  @doc """
  Checks if the model supports multimodal inputs.

  Returns True if the model is multimodal with any non-zero supported
  modalities, otherwise returns False, effectively running in
  text-only mode.

  ## Parameters

  - `model_config` (term())

  ## Returns

  - `boolean()`
  """
  @spec supports_multimodal_inputs(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def supports_multimodal_inputs(ref, model_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :supports_multimodal_inputs, [model_config], opts)
  end
end
