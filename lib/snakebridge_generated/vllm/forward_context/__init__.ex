# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.forward_context

defmodule Vllm.ForwardContext.Module do
  @moduledoc """
  Submodule bindings for `vllm.forward_context`.

  ## Version

  - Requested: 0.14.0
  - Observed at generation: 0.14.0

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Vllm.ForwardContext.Module.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Vllm.ForwardContext.Module.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Vllm.ForwardContext.Module.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Vllm.ForwardContext.Module.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "vllm.forward_context"
  @doc false
  def __snakebridge_library__, do: "vllm"

  @doc """
  Python binding for `vllm.forward_context._compute_chunked_local_num_tokens`.

  ## Parameters

  - `num_tokens_across_dp_cpu` (term())
  - `sequence_parallel_size` (integer())
  - `max_num_tokens` (integer())
  - `chunk_idx` (integer())

  ## Returns

  - `list(integer())`
  """
  @spec _compute_chunked_local_num_tokens(term(), integer(), integer(), integer(), keyword()) ::
          {:ok, list(integer())} | {:error, Snakepit.Error.t()}
  def _compute_chunked_local_num_tokens(
        num_tokens_across_dp_cpu,
        sequence_parallel_size,
        max_num_tokens,
        chunk_idx,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_compute_chunked_local_num_tokens,
      [num_tokens_across_dp_cpu, sequence_parallel_size, max_num_tokens, chunk_idx],
      opts
    )
  end

  @doc """
  Python binding for `vllm.forward_context._compute_sp_num_tokens`.

  ## Parameters

  - `num_tokens_across_dp_cpu` (term())
  - `sequence_parallel_size` (integer())

  ## Returns

  - `list(integer())`
  """
  @spec _compute_sp_num_tokens(term(), integer(), keyword()) ::
          {:ok, list(integer())} | {:error, Snakepit.Error.t()}
  def _compute_sp_num_tokens(num_tokens_across_dp_cpu, sequence_parallel_size, opts \\ []) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_compute_sp_num_tokens,
      [num_tokens_across_dp_cpu, sequence_parallel_size],
      opts
    )
  end

  @doc """
  Python binding for `vllm.forward_context._forward_context`.

  ## Returns

  - `term()`
  """
  @spec _forward_context() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _forward_context(
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _forward_context() do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [], [])
  end

  def _forward_context(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [], opts)
  end

  def _forward_context(arg1) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1], [])
  end

  def _forward_context(arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1], opts)
  end

  def _forward_context(arg1, arg2) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2], [])
  end

  def _forward_context(arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2], opts)
  end

  def _forward_context(arg1, arg2, arg3) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3], [])
  end

  def _forward_context(arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3], opts)
  end

  def _forward_context(arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3, arg4], [])
  end

  def _forward_context(arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3, arg4], opts)
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_forward_context, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      []
    )
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      opts
    )
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def _forward_context(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_forward_context,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Python module attribute `vllm.forward_context.batchsize_forward_time`.

  ## Returns

  - `term()`
  """
  @spec batchsize_forward_time() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def batchsize_forward_time() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :batchsize_forward_time)
  end

  @doc """
  Python module attribute `vllm.forward_context.batchsize_logging_interval`.

  ## Returns

  - `float()`
  """
  @spec batchsize_logging_interval() :: {:ok, float()} | {:error, Snakepit.Error.t()}
  def batchsize_logging_interval() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :batchsize_logging_interval)
  end

  @doc """
  Coordinates amongst all DP ranks to determine if and how the full batch

  should be split into microbatches.

  ## Parameters

  - `num_tokens_unpadded` - Number of tokens without accounting for padding
  - `allow_microbatching` - If microbatching should be attempted
  - `allow_dp_padding` - If all DP ranks should be padded up to the same value
  - `parallel_config` - The parallel config
  - `num_tokens_padded` - Number of tokens including any non-DP padding (CUDA graphs, TP, etc)
  - `uniform_decode` - Only used if allow_microbatching is True. True if the batch only contains single token decodes
  - `num_scheduled_tokens_per_request` - Only used if allow_microbatching is True. The number of tokens per request.
  - `cudagraph_mode` - The cudagraph mode for this rank (0=NONE, 1=PIECEWISE, 2=FULL)

  ## Returns

  - `{boolean(), term(), integer()}`
  """
  @spec coordinate_batch_across_dp(integer(), boolean(), boolean(), term()) ::
          {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(integer(), boolean(), boolean(), term(), keyword()) ::
          {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(integer(), boolean(), boolean(), term(), term()) ::
          {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(integer(), boolean(), boolean(), term(), term(), keyword()) ::
          {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(integer(), boolean(), boolean(), term(), term(), term()) ::
          {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(
          integer(),
          boolean(),
          boolean(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(
          integer(),
          boolean(),
          boolean(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(
          integer(),
          boolean(),
          boolean(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(
          integer(),
          boolean(),
          boolean(),
          term(),
          term(),
          term(),
          term(),
          integer()
        ) :: {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  @spec coordinate_batch_across_dp(
          integer(),
          boolean(),
          boolean(),
          term(),
          term(),
          term(),
          term(),
          integer(),
          keyword()
        ) :: {:ok, {boolean(), term(), integer()}} | {:error, Snakepit.Error.t()}
  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [num_tokens_unpadded, allow_microbatching, allow_dp_padding, parallel_config],
      []
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [num_tokens_unpadded, allow_microbatching, allow_dp_padding, parallel_config],
      opts
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded
      ],
      []
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded
      ],
      opts
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode
      ],
      []
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode
      ],
      opts
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request
      ],
      []
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request
      ],
      opts
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request,
        cudagraph_mode
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request,
        cudagraph_mode
      ],
      []
    )
  end

  def coordinate_batch_across_dp(
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request,
        cudagraph_mode,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :coordinate_batch_across_dp,
      [
        num_tokens_unpadded,
        allow_microbatching,
        allow_dp_padding,
        parallel_config,
        num_tokens_padded,
        uniform_decode,
        num_scheduled_tokens_per_request,
        cudagraph_mode
      ],
      opts
    )
  end

  @doc """
  Python binding for `vllm.forward_context.create_forward_context`.

  ## Parameters

  - `attn_metadata` (term())
  - `vllm_config` (term())
  - `virtual_engine` (integer() default: 0)
  - `dp_metadata` (term() default: None)
  - `cudagraph_runtime_mode` (term() default: <CUDAGraphMode.NONE: 0>)
  - `batch_descriptor` (term() default: None)
  - `ubatch_slices` (term() default: None)
  - `additional_kwargs` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec create_forward_context(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(
          term(),
          term(),
          integer(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(term(), term(), integer(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec create_forward_context(
          term(),
          term(),
          integer(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def create_forward_context(attn_metadata, vllm_config) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config],
      []
    )
  end

  def create_forward_context(attn_metadata, vllm_config, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config],
      opts
    )
  end

  def create_forward_context(attn_metadata, vllm_config, virtual_engine) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine],
      []
    )
  end

  def create_forward_context(attn_metadata, vllm_config, virtual_engine, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine],
      opts
    )
  end

  def create_forward_context(attn_metadata, vllm_config, virtual_engine, dp_metadata) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine, dp_metadata],
      []
    )
  end

  def create_forward_context(attn_metadata, vllm_config, virtual_engine, dp_metadata, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine, dp_metadata],
      opts
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine, dp_metadata, cudagraph_runtime_mode],
      []
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [attn_metadata, vllm_config, virtual_engine, dp_metadata, cudagraph_runtime_mode],
      opts
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor
      ],
      []
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor
      ],
      opts
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ],
      []
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ],
      opts
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        additional_kwargs
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        additional_kwargs
      ],
      []
    )
  end

  def create_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        additional_kwargs,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :create_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        dp_metadata,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        additional_kwargs
      ],
      opts
    )
  end

  @doc """
  Python module attribute `vllm.forward_context.current_platform`.

  ## Returns

  - `term()`
  """
  @spec current_platform() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def current_platform() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :current_platform)
  end

  @doc """
  Python module attribute `vllm.forward_context.forward_start_time`.

  ## Returns

  - `integer()`
  """
  @spec forward_start_time() :: {:ok, integer()} | {:error, Snakepit.Error.t()}
  def forward_start_time() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :forward_start_time)
  end

  @doc """
  Get the current forward context.

  ## Returns

  - `Vllm.ForwardContext.t()`
  """
  @spec get_forward_context(keyword()) ::
          {:ok, Vllm.ForwardContext.t()} | {:error, Snakepit.Error.t()}
  def get_forward_context(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_forward_context, [], opts)
  end

  @doc """
  The main purpose of this function is to ensure that loggers are

  retrieved in such a way that we can be sure the root vllm logger has
  already been configured.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `Vllm.Logger.VllmLogger.t()`
  """
  @spec init_logger(String.t(), keyword()) ::
          {:ok, Vllm.Logger.VllmLogger.t()} | {:error, Snakepit.Error.t()}
  def init_logger(name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :init_logger, [name], opts)
  end

  @doc """
  Python binding for `vllm.forward_context.is_forward_context_available`.

  ## Returns

  - `boolean()`
  """
  @spec is_forward_context_available(keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_forward_context_available(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :is_forward_context_available, [], opts)
  end

  @doc """
  Python module attribute `vllm.forward_context.last_logging_time`.

  ## Returns

  - `integer()`
  """
  @spec last_logging_time() :: {:ok, integer()} | {:error, Snakepit.Error.t()}
  def last_logging_time() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :last_logging_time)
  end

  @doc """
  Python module attribute `vllm.forward_context.logger`.

  ## Returns

  - `term()`
  """
  @spec logger() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logger() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :logger)
  end

  @doc """
  A context manager that overrides the current forward context.

  This is used to override the forward context for a specific
  forward pass.

  ## Parameters

  - `forward_context` (term())

  ## Returns

  - `term()`
  """
  @spec override_forward_context(term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def override_forward_context(forward_context, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :override_forward_context, [forward_context], opts)
  end

  @doc """
  A context manager that stores the current forward context,

  can be attention metadata, etc.
  Here we can inject common logic for every model forward pass.

  ## Parameters

  - `attn_metadata` (term())
  - `vllm_config` (term())
  - `virtual_engine` (integer() default: 0)
  - `num_tokens` (term() default: None)
  - `num_tokens_across_dp` (term() default: None)
  - `cudagraph_runtime_mode` (term() default: <CUDAGraphMode.NONE: 0>)
  - `batch_descriptor` (term() default: None)
  - `ubatch_slices` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec set_forward_context(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(term(), term(), integer(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec set_forward_context(
          term(),
          term(),
          integer(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def set_forward_context(attn_metadata, vllm_config) do
    SnakeBridge.Runtime.call(__MODULE__, :set_forward_context, [attn_metadata, vllm_config], [])
  end

  def set_forward_context(attn_metadata, vllm_config, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :set_forward_context, [attn_metadata, vllm_config], opts)
  end

  def set_forward_context(attn_metadata, vllm_config, virtual_engine) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine],
      []
    )
  end

  def set_forward_context(attn_metadata, vllm_config, virtual_engine, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine],
      opts
    )
  end

  def set_forward_context(attn_metadata, vllm_config, virtual_engine, num_tokens) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine, num_tokens],
      []
    )
  end

  def set_forward_context(attn_metadata, vllm_config, virtual_engine, num_tokens, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine, num_tokens],
      opts
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine, num_tokens, num_tokens_across_dp],
      []
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [attn_metadata, vllm_config, virtual_engine, num_tokens, num_tokens_across_dp],
      opts
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode
      ],
      []
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode
      ],
      opts
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor
      ],
      []
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor
      ],
      opts
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ],
      []
    )
  end

  def set_forward_context(
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :set_forward_context,
      [
        attn_metadata,
        vllm_config,
        virtual_engine,
        num_tokens,
        num_tokens_across_dp,
        cudagraph_runtime_mode,
        batch_descriptor,
        ubatch_slices
      ],
      opts
    )
  end

  @doc """
  Python module attribute `vllm.forward_context.track_batchsize`.

  ## Returns

  - `boolean()`
  """
  @spec track_batchsize() :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def track_batchsize() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :track_batchsize)
  end

  @doc """
  Built-in mutable sequence.

  If no argument is given, the constructor creates a new empty list.
  The argument must be an iterable if specified.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec u_batch_slices(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def u_batch_slices(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "UBatchSlices", [], opts)
  end
end
