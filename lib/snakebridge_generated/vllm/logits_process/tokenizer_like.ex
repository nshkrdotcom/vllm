# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.logits_process
# Python class: TokenizerLike

defmodule Vllm.LogitsProcess.TokenizerLike do
  @moduledoc """
  Base class for protocol classes.

  Protocol classes are defined as::

      class Proto(Protocol):
          def meth(self) -> int:
              ...

  Such classes are primarily used with static type checkers that recognize
  structural subtyping (static duck-typing).

  For example::

      class C:
          def meth(self) -> int:
              return 0

      def func(x: Proto) -> int:
          return x.meth()

      func(C())  # Passes static type check

  See PEP 544 for details. Protocol classes decorated with
  @typing.runtime_checkable act as simple-minded runtime protocols that check
  only the presence of given attributes, ignoring their type signatures.
  Protocol classes can be generic, they are defined as::

      class GenProto[T](Protocol):
          def meth(self) -> T:
              ...
  """
  def __snakebridge_python_name__, do: "vllm.logits_process"
  def __snakebridge_python_class__, do: "TokenizerLike"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `TokenizerLike`.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `TokenizerLike.apply_chat_template`.

  ## Parameters

  - `messages` (list(term()))
  - `tools` (term() default: None)
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec apply_chat_template(SnakeBridge.Ref.t(), list(term()), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def apply_chat_template(ref, messages, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :apply_chat_template,
      [messages] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `TokenizerLike.convert_ids_to_tokens`.

  ## Parameters

  - `ids` (list(integer()))
  - `skip_special_tokens` (boolean() default: False)

  ## Returns

  - `list(String.t())`
  """
  @spec convert_ids_to_tokens(SnakeBridge.Ref.t(), list(integer()), list(term()), keyword()) ::
          {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
  def convert_ids_to_tokens(ref, ids, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :convert_ids_to_tokens, [ids] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `TokenizerLike.convert_tokens_to_ids`.

  ## Parameters

  - `tokens` (term())

  ## Returns

  - `term()`
  """
  @spec convert_tokens_to_ids(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def convert_tokens_to_ids(ref, tokens, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :convert_tokens_to_ids, [tokens], opts)
  end

  @doc """
  Python method `TokenizerLike.convert_tokens_to_string`.

  ## Parameters

  - `tokens` (list(String.t()))

  ## Returns

  - `String.t()`
  """
  @spec convert_tokens_to_string(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def convert_tokens_to_string(ref, tokens, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :convert_tokens_to_string, [tokens], opts)
  end

  @doc """
  Python method `TokenizerLike.decode`.

  ## Parameters

  - `ids` (term())
  - `skip_special_tokens` (boolean() default: False)

  ## Returns

  - `String.t()`
  """
  @spec decode(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def decode(ref, ids, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :decode, [ids] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `TokenizerLike.encode`.

  ## Parameters

  - `text` (String.t())
  - `truncation` (term() default: None)
  - `max_length` (term() default: None)
  - `add_special_tokens` (boolean() default: True)

  ## Returns

  - `list(integer())`
  """
  @spec encode(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, list(integer())} | {:error, Snakepit.Error.t()}
  def encode(ref, text, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :encode, [text] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `TokenizerLike.from_pretrained`.

  ## Parameters

  - `path_or_repo_id` (term())
  - `args` (term())
  - `trust_remote_code` (boolean() keyword-only default: False)
  - `revision` (term() keyword-only default: None)
  - `download_dir` (term() keyword-only default: None)
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec from_pretrained(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_pretrained(ref, path_or_repo_id, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :from_pretrained,
      [path_or_repo_id] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `TokenizerLike.get_added_vocab`.

  ## Returns

  - `%{optional(String.t()) => integer()}`
  """
  @spec get_added_vocab(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => integer()}} | {:error, Snakepit.Error.t()}
  def get_added_vocab(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_added_vocab, [], opts)
  end

  @doc """
  Python method `TokenizerLike.get_vocab`.

  ## Returns

  - `%{optional(String.t()) => integer()}`
  """
  @spec get_vocab(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => integer()}} | {:error, Snakepit.Error.t()}
  def get_vocab(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_vocab, [], opts)
  end

  @doc """
  Python method `TokenizerLike.num_special_tokens_to_add`.

  ## Returns

  - `integer()`
  """
  @spec num_special_tokens_to_add(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def num_special_tokens_to_add(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :num_special_tokens_to_add, [], opts)
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end

  @spec _is_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _is_protocol(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_is_protocol)
  end

  @spec _is_runtime_protocol(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _is_runtime_protocol(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_is_runtime_protocol)
  end

  @spec all_special_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_special_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :all_special_ids)
  end

  @spec all_special_tokens(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def all_special_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :all_special_tokens)
  end

  @spec bos_token_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bos_token_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :bos_token_id)
  end

  @spec eos_token_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def eos_token_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :eos_token_id)
  end

  @spec is_fast(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_fast(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_fast)
  end

  @spec max_token_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_token_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_token_id)
  end

  @spec pad_token_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def pad_token_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :pad_token_id)
  end

  @spec truncation_side(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def truncation_side(ref) do
    SnakeBridge.Runtime.get_attr(ref, :truncation_side)
  end

  @spec vocab_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def vocab_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :vocab_size)
  end
end
