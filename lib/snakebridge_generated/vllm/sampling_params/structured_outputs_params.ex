# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.sampling_params
# Python class: StructuredOutputsParams

defmodule Vllm.SamplingParams.StructuredOutputsParams do
  @moduledoc """
  Sampling parameters for text generation.
  """
  def __snakebridge_python_name__, do: "vllm.sampling_params"
  def __snakebridge_python_class__, do: "StructuredOutputsParams"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Sampling parameters for text generation.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Returns True if all structured-output constraint fields are None.

  ## Returns

  - `boolean()`
  """
  @spec all_constraints_none(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def all_constraints_none(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :all_constraints_none, [], opts)
  end

  @doc """
  Returns True if all structured-output constraint fields are None.

  ## Returns

  - `boolean()`
  """
  @spec all_non_structural_tag_constraints_none(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def all_non_structural_tag_constraints_none(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :all_non_structural_tag_constraints_none, [], opts)
  end

  @spec _backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_backend)
  end

  @spec _backend_was_auto(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _backend_was_auto(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_backend_was_auto)
  end

  @spec choice(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def choice(ref) do
    SnakeBridge.Runtime.get_attr(ref, :choice)
  end

  @spec disable_additional_properties(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_additional_properties(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_additional_properties)
  end

  @spec disable_any_whitespace(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_any_whitespace(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_any_whitespace)
  end

  @spec disable_fallback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_fallback(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_fallback)
  end

  @spec grammar(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grammar(ref) do
    SnakeBridge.Runtime.get_attr(ref, :grammar)
  end

  @spec json(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def json(ref) do
    SnakeBridge.Runtime.get_attr(ref, :json)
  end

  @spec json_object(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def json_object(ref) do
    SnakeBridge.Runtime.get_attr(ref, :json_object)
  end

  @spec regex(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def regex(ref) do
    SnakeBridge.Runtime.get_attr(ref, :regex)
  end

  @spec structural_tag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def structural_tag(ref) do
    SnakeBridge.Runtime.get_attr(ref, :structural_tag)
  end

  @spec whitespace_pattern(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def whitespace_pattern(ref) do
    SnakeBridge.Runtime.get_attr(ref, :whitespace_pattern)
  end
end
