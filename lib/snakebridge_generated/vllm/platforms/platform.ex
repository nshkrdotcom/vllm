# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.platforms
# Python class: Platform

defmodule Vllm.Platforms.Platform do
  @moduledoc """
  Wrapper for Python class Platform.
  """
  def __snakebridge_python_name__, do: "vllm.platforms"
  def __snakebridge_python_class__, do: "Platform"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Get the total memory of a device in bytes.

  ## Parameters

  - `device_id` (integer() default: 0)

  ## Returns

  - `integer()`
  """
  @spec get_device_total_memory(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_device_total_memory(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get_device_total_memory, [] ++ List.wrap(args), opts)
  end

  @doc """
  Return the memory usage in bytes.

  ## Parameters

  - `device` (((term() | String.t()) | integer()) | nil default: None)

  ## Returns

  - `float()`
  """
  @spec get_current_memory_usage(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, float()} | {:error, Snakepit.Error.t()}
  def get_current_memory_usage(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get_current_memory_usage, [] ++ List.wrap(args), opts)
  end

  @doc """
  Returns True if the device capability is any <major>.x.

  Mirrors CUDA 13 'family' architecture semantics (e.g. 10.x, 11.x, 12.x).

  ## Parameters

  - `capability` (integer())
  - `device_id` (integer() default: 0)

  ## Returns

  - `boolean()`
  """
  @spec is_device_capability_family(SnakeBridge.Ref.t(), integer(), list(term()), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_device_capability_family(ref, capability, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :is_device_capability_family,
      [capability] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Returns if the current platform needs to sync weight loader.

  ## Returns

  - `boolean()`
  """
  @spec use_sync_weight_loader(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def use_sync_weight_loader(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :use_sync_weight_loader, [], opts)
  end

  @doc """
  Init platform-specific torch distributed process group.

  ## Parameters

  - `backend` (String.t())
  - `prefix_store` (term())
  - `group_rank` (integer())
  - `group_size` (integer())
  - `timeout` (term())

  ## Returns

  - `term()`
  """
  @spec stateless_init_device_torch_dist_pg(
          SnakeBridge.Ref.t(),
          String.t(),
          term(),
          integer(),
          integer(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stateless_init_device_torch_dist_pg(
        ref,
        backend,
        prefix_store,
        group_rank,
        group_size,
        timeout,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :stateless_init_device_torch_dist_pg,
      [backend, prefix_store, group_rank, group_size, timeout],
      opts
    )
  end

  @doc """
  Python method `Platform.device_id_to_physical_device_id`.

  ## Parameters

  - `device_id` (integer())

  ## Returns

  - `term()`
  """
  @spec device_id_to_physical_device_id(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def device_id_to_physical_device_id(ref, device_id, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :device_id_to_physical_device_id, [device_id], opts)
  end

  @doc """
  Checks whether pin memory is available on the current platform.

  ## Returns

  - `boolean()`
  """
  @spec is_pin_memory_available(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_pin_memory_available(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_pin_memory_available, [], opts)
  end

  @doc """
  Return the platform specific values for (-inf, inf)

  ## Parameters

  - `dtype` (term())

  ## Returns

  - `{float(), float()}`
  """
  @spec get_infinity_values(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, {float(), float()}} | {:error, Snakepit.Error.t()}
  def get_infinity_values(ref, dtype, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_infinity_values, [dtype], opts)
  end

  @doc """
  Check if the dtype is supported by the current platform.

  ## Parameters

  - `dtype` (term())

  ## Returns

  - `term()`
  """
  @spec check_if_supports_dtype(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def check_if_supports_dtype(ref, dtype, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :check_if_supports_dtype, [dtype], opts)
  end

  @doc """
  Python method `Platform.is_out_of_tree`.

  ## Returns

  - `boolean()`
  """
  @spec is_out_of_tree(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_out_of_tree(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_out_of_tree, [], opts)
  end

  @doc """
  Python method `Platform.get_max_output_tokens`.

  ## Parameters

  - `prompt_len` (integer())

  ## Returns

  - `integer()`
  """
  @spec get_max_output_tokens(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_max_output_tokens(ref, prompt_len, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_max_output_tokens, [prompt_len], opts)
  end

  @doc """
  Test whether this platform is compatible with a device capability.

  The `capability` argument can either be:

  - A tuple `(major, minor)`.
  - An integer `<major><minor>`. (See
  [`DeviceCapability.to_int`][vllm.platforms.interface.DeviceCapability.to_int])

  ## Parameters

  - `capability` (term())
  - `device_id` (integer() default: 0)

  ## Returns

  - `boolean()`
  """
  @spec has_device_capability(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def has_device_capability(ref, capability, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :has_device_capability,
      [capability] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Get the name of a device.

  ## Parameters

  - `device_id` (integer() default: 0)

  ## Returns

  - `String.t()`
  """
  @spec get_device_name(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_device_name(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get_device_name, [] ++ List.wrap(args), opts)
  end

  @doc """
  Returns the nixl memory type for the current platform.

  ## Returns

  - `term()`
  """
  @spec get_nixl_memory_type(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_nixl_memory_type(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_nixl_memory_type, [], opts)
  end

  @doc """
  Determine the CPU architecture of the current system.

  Returns CpuArchEnum indicating the architecture type.

  ## Returns

  - `term()`
  """
  @spec get_cpu_architecture(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cpu_architecture(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_cpu_architecture, [], opts)
  end

  @doc """
  Verify whether the quantization is supported by the current platform.

  ## Parameters

  - `quant` (String.t())

  ## Returns

  - `nil`
  """
  @spec verify_quantization(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify_quantization(ref, quant, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :verify_quantization, [quant], opts)
  end

  @doc """
  Verify whether the current platform supports the specified model

  architecture.

  - This will raise an Error or Warning based on the model support on
  the current platform.
  - By default all models are considered supported.

  ## Parameters

  - `model_arch` (String.t())

  ## Returns

  - `nil`
  """
  @spec verify_model_arch(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify_model_arch(ref, model_arch, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :verify_model_arch, [model_arch], opts)
  end

  @doc """
  Returns if the hybrid kv cache is supported by the current platform.

  ## Returns

  - `boolean()`
  """
  @spec support_hybrid_kv_cache(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def support_hybrid_kv_cache(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :support_hybrid_kv_cache, [], opts)
  end

  @doc """
  Python method `Platform.is_unspecified`.

  ## Returns

  - `boolean()`
  """
  @spec is_unspecified(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_unspecified(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_unspecified, [], opts)
  end

  @doc """
  Get the attention backend class of a device.

  ## Parameters

  - `selected_backend` (term())
  - `attn_selector_config` (term())

  ## Returns

  - `String.t()`
  """
  @spec get_attn_backend_cls(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_attn_backend_cls(ref, selected_backend, attn_selector_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :get_attn_backend_cls,
      [selected_backend, attn_selector_config],
      opts
    )
  end

  @doc """
  Returns a mapping from device_type to a tuple of supported

  kv_buffer_device for nixl.

  ## Returns

  - `%{optional(String.t()) => {String.t(), term()}}`
  """
  @spec get_nixl_supported_devices(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => {String.t(), term()}}} | {:error, Snakepit.Error.t()}
  def get_nixl_supported_devices(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_nixl_supported_devices, [], opts)
  end

  @doc """
  Returns the preferred FP8 type on the current platform.

  See the documentation for is_fp8_fnuz for details.

  ## Returns

  - `term()`
  """
  @spec fp8_dtype(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fp8_dtype(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :fp8_dtype, [], opts)
  end

  @doc """
  Python method `Platform.is_rocm`.

  ## Returns

  - `boolean()`
  """
  @spec is_rocm(SnakeBridge.Ref.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_rocm(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_rocm, [], opts)
  end

  @doc """
  Check max_model_len for the current platform.

  ## Parameters

  - `max_model_len` (integer())

  ## Returns

  - `integer()`
  """
  @spec check_max_model_len(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def check_max_model_len(ref, max_model_len, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :check_max_model_len, [max_model_len], opts)
  end

  @doc """
  Return the punica wrapper for current platform.

  ## Returns

  - `String.t()`
  """
  @spec get_punica_wrapper(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_punica_wrapper(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_punica_wrapper, [], opts)
  end

  @doc """
  Stateless version of [torch.cuda.is_available][].

  ## Returns

  - `boolean()`
  """
  @spec is_cuda_alike(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_cuda_alike(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_cuda_alike, [], opts)
  end

  @doc """
  Get the pass manager class for this platform.

  It will be registered as a custom pass under the current_platform.pass_key.

  ## Returns

  - `String.t()`
  """
  @spec get_pass_manager_cls(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_pass_manager_cls(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_pass_manager_cls, [], opts)
  end

  @doc """
  Stateless version of [torch.cuda.get_device_capability][].

  ## Parameters

  - `device_id` (integer() default: 0)

  ## Returns

  - `term()`
  """
  @spec get_device_capability(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_device_capability(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get_device_capability, [] ++ List.wrap(args), opts)
  end

  @doc """
  Get the vision attention backend class of a device.

  NOTE: ViT Attention should be checked and override in the platform-specific
  implementation. we should not override this in any other places, like
  the model_executor/models/<model_name>.py.

  We check if the backend is None or not:
      1. If not, check if the backend is supported by the platform.
      2. If None, continue to the default selection logic.

  ## Parameters

  - `head_size` (integer())
  - `dtype` (term())
  - `backend` (term() | nil default: None)

  ## Returns

  - `term()`
  """
  @spec get_vit_attn_backend(SnakeBridge.Ref.t(), integer(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_vit_attn_backend(ref, head_size, dtype, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :get_vit_attn_backend,
      [head_size, dtype] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Returns if the graph mode is supported by the current platform.

  ## Returns

  - `boolean()`
  """
  @spec support_static_graph_mode(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def support_static_graph_mode(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :support_static_graph_mode, [], opts)
  end

  @doc """
  Set the device for the current platform.

  ## Parameters

  - `device` (term())

  ## Returns

  - `nil`
  """
  @spec set_device(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def set_device(ref, device, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :set_device, [device], opts)
  end

  @doc """
  Python method `Platform.is_cpu`.

  ## Returns

  - `boolean()`
  """
  @spec is_cpu(SnakeBridge.Ref.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_cpu(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_cpu, [], opts)
  end

  @doc """
  Return the global graph pool for this platform.

  ## Returns

  - `term()`
  """
  @spec get_global_graph_pool(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_global_graph_pool(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_global_graph_pool, [], opts)
  end

  @doc """
  Python method `Platform.is_xpu`.

  ## Returns

  - `boolean()`
  """
  @spec is_xpu(SnakeBridge.Ref.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_xpu(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_xpu, [], opts)
  end

  @doc """
  Returns if custom allreduce is supported on the current platform

  ## Returns

  - `boolean()`
  """
  @spec use_custom_allreduce(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def use_custom_allreduce(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :use_custom_allreduce, [], opts)
  end

  @doc """
  Import any platform-specific C kernels.

  ## Returns

  - `nil`
  """
  @spec import_kernels(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def import_kernels(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :import_kernels, [], opts)
  end

  @doc """
  Test whether this platform has exactly the specified device capability.

  The `capability` argument can either be:

  - A tuple `(major, minor)`.
  - An integer `<major><minor>`. (See
  [`DeviceCapability.to_int`][vllm.platforms.interface.DeviceCapability.to_int])

  ## Parameters

  - `capability` (term())
  - `device_id` (integer() default: 0)

  ## Returns

  - `boolean()`
  """
  @spec is_device_capability(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_device_capability(ref, capability, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :is_device_capability,
      [capability] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Check and update the configuration for the current platform.

  It can raise an exception if the configuration is not compatible with
  the current platform, or it can update the configuration to make it
  compatible with the current platform.

  The config is passed by reference, so it can be modified in place.

  ## Parameters

  - `vllm_config` (term())

  ## Returns

  - `nil`
  """
  @spec check_and_update_config(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def check_and_update_config(ref, vllm_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :check_and_update_config, [vllm_config], opts)
  end

  @doc """
  Returns whether the preferred FP8 type is FNUZ on the current platform.

  There are two representations of FP8, OCP FP8 and FNUZ FP8.
  The OCP specification can be found at https://tinyurl.com/b7jvwpft.
  The FNUZ specification can be found at https://tinyurl.com/5n6hwwu5.

  AMD's MI300 and MI325 have native hardware support for FNUZ. All other
  hardware has converged on the OCP FP8 standard.

  ## Returns

  - `boolean()`
  """
  @spec is_fp8_fnuz(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_fp8_fnuz(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_fp8_fnuz, [], opts)
  end

  @doc """
  Get the custom compile backend for current platform.

  ## Returns

  - `String.t()`
  """
  @spec get_compile_backend(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_compile_backend(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_compile_backend, [], opts)
  end

  @doc """
  Python method `Platform.is_cuda`.

  ## Returns

  - `boolean()`
  """
  @spec is_cuda(SnakeBridge.Ref.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_cuda(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_cuda, [], opts)
  end

  @doc """
  Get the uuid of a device, e.g. the PCI bus ID.

  ## Parameters

  - `device_id` (integer() default: 0)

  ## Returns

  - `String.t()`
  """
  @spec get_device_uuid(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_device_uuid(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :get_device_uuid, [] ++ List.wrap(args), opts)
  end

  @doc """
  Python method `Platform.is_sleep_mode_available`.

  ## Returns

  - `boolean()`
  """
  @spec is_sleep_mode_available(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_sleep_mode_available(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_sleep_mode_available, [], opts)
  end

  @doc """
  Set the seed of each random module.

  `torch.manual_seed` will set seed on all devices.

  Loosely based on: https://github.com/Lightning-AI/pytorch-lightning/blob/2.4.0/src/lightning/fabric/utilities/seed.py#L20

  ## Parameters

  - `seed` (term() default: None)

  ## Returns

  - `nil`
  """
  @spec seed_everything(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def seed_everything(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :seed_everything, [] ++ List.wrap(args), opts)
  end

  @doc """
  Returns whether the current platform supports FP8 types.

  ## Returns

  - `boolean()`
  """
  @spec supports_fp8(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def supports_fp8(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :supports_fp8, [], opts)
  end

  @doc """
  A device-specific wrapper of `torch.inference_mode`.

  This wrapper is recommended because some hardware backends such as TPU
  do not support `torch.inference_mode`. In such a case, they will fall
  back to `torch.no_grad` by overriding this method.

  ## Returns

  - `term()`
  """
  @spec inference_mode(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def inference_mode(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :inference_mode, [], opts)
  end

  @doc """
  Whether to use allgather in LogitsProcessor to gather the logits.

  ## Returns

  - `boolean()`
  """
  @spec use_all_gather(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def use_all_gather(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :use_all_gather, [], opts)
  end

  @doc """
  Set some additional forward context for the current platform if needs.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec set_additional_forward_context(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def set_additional_forward_context(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :set_additional_forward_context,
      [] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Returns True if we register attention as one giant opaque custom op

  on the current platform

  ## Returns

  - `boolean()`
  """
  @spec opaque_attention_op(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def opaque_attention_op(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :opaque_attention_op, [], opts)
  end

  @doc """
  Returns how much padding the LoRA logits need for kernels

  ## Returns

  - `integer()`
  """
  @spec get_lora_vocab_padding_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_lora_vocab_padding_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_lora_vocab_padding_size, [], opts)
  end

  @doc """
  Wrap the original weight loader to make it synced.

  ## Parameters

  - `original_weight_loader` (term())

  ## Returns

  - `term()`
  """
  @spec make_synced_weight_loader(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def make_synced_weight_loader(ref, original_weight_loader, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :make_synced_weight_loader,
      [original_weight_loader],
      opts
    )
  end

  @doc """
  Do some pre-registration or update action for the current platform.

  This function is called before global VllmConfig is initialized or cli
  arguments are parsed. It's used for out-of-tree platforms to register or
  update the configuration.

  For example, the out-of-tree quantization config can be imported and
  registered here dynamically.

  ## Parameters

  - `parser` (term() default: None)

  ## Returns

  - `nil`
  """
  @spec pre_register_and_update(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def pre_register_and_update(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :pre_register_and_update, [] ++ List.wrap(args), opts)
  end

  @doc """
  Checks if the platform allows inplace memory updates

  ## Returns

  - `boolean()`
  """
  @spec can_update_inplace(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def can_update_inplace(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :can_update_inplace, [], opts)
  end

  @doc """
  Raises if this request is unsupported on this platform

  ## Parameters

  - `prompt` (term())
  - `params` (term())
  - `processed_inputs` (term())

  ## Returns

  - `nil`
  """
  @spec validate_request(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def validate_request(ref, prompt, params, processed_inputs, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :validate_request,
      [prompt, params, processed_inputs],
      opts
    )
  end

  @doc """
  Python method `Platform.is_tpu`.

  ## Returns

  - `boolean()`
  """
  @spec is_tpu(SnakeBridge.Ref.t(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_tpu(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_tpu, [], opts)
  end

  @doc """
  Get device specific communicator class for distributed communication.

  ## Returns

  - `String.t()`
  """
  @spec get_device_communicator_cls(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_device_communicator_cls(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_device_communicator_cls, [], opts)
  end

  @doc """
  Python method `Platform.get_supported_vit_attn_backends`.

  ## Returns

  - `list(term())`
  """
  @spec get_supported_vit_attn_backends(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, list(term())} | {:error, Snakepit.Error.t()}
  def get_supported_vit_attn_backends(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_supported_vit_attn_backends, [], opts)
  end

  @doc """
  Get static graph wrapper class for static graph.

  ## Returns

  - `String.t()`
  """
  @spec get_static_graph_wrapper_cls(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def get_static_graph_wrapper_cls(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_static_graph_wrapper_cls, [], opts)
  end

  @doc """
  Returns whether the current platform supports MX types.

  ## Returns

  - `boolean()`
  """
  @spec supports_mx(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def supports_mx(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :supports_mx, [], opts)
  end

  @spec _global_graph_pool(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _global_graph_pool(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_global_graph_pool)
  end

  @spec additional_env_vars(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def additional_env_vars(ref) do
    SnakeBridge.Runtime.get_attr(ref, :additional_env_vars)
  end

  @spec device_control_env_var(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def device_control_env_var(ref) do
    SnakeBridge.Runtime.get_attr(ref, :device_control_env_var)
  end

  @spec dispatch_key(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dispatch_key(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dispatch_key)
  end

  @spec dist_backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dist_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dist_backend)
  end

  @spec pass_key(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def pass_key(ref) do
    SnakeBridge.Runtime.get_attr(ref, :pass_key)
  end

  @spec ray_device_key(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ray_device_key(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ray_device_key)
  end

  @spec simple_compile_backend(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def simple_compile_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :simple_compile_backend)
  end

  @spec supported_dtypes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def supported_dtypes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :supported_dtypes)
  end

  @spec supported_quantization(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def supported_quantization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :supported_quantization)
  end
end
