# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.tool_parsers
# Python class: ToolParserManager

defmodule Vllm.ToolParsers.ToolParserManager do
  @moduledoc """
  Central registry for ToolParser implementations.

  Supports two modes:
    - Eager (immediate) registration via `register_module`
    - Lazy registration via `register_lazy_module`
  """
  def __snakebridge_python_name__, do: "vllm.tool_parsers"
  def __snakebridge_python_class__, do: "ToolParserManager"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Import and register a lazily loaded parser.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `term()`
  """
  @spec _load_lazy_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _load_lazy_parser(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_load_lazy_parser, [name], opts)
  end

  @doc """
  Register a ToolParser class immediately.

  ## Parameters

  - `module` (term())
  - `module_name` (term() default: None)
  - `force` (boolean() default: True)

  ## Returns

  - `nil`
  """
  @spec _register_module(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _register_module(ref, module, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :_register_module, [module] ++ List.wrap(args), opts)
  end

  @doc """
  Retrieve a registered or lazily registered ToolParser class.

  If the parser is lazily registered,
  it will be imported and cached on first access.
  Raises KeyError if not found.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `term()`
  """
  @spec get_tool_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_tool_parser(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_tool_parser, [name], opts)
  end

  @doc """
  Import a user-defined parser file from arbitrary path.

  ## Parameters

  - `plugin_path` (String.t())

  ## Returns

  - `nil`
  """
  @spec import_tool_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def import_tool_parser(ref, plugin_path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :import_tool_parser, [plugin_path], opts)
  end

  @doc """
  Return names of all eagerly and lazily registered tool parsers.

  ## Returns

  - `list(String.t())`
  """
  @spec list_registered(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
  def list_registered(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :list_registered, [], opts)
  end

  @doc """
  Register a lazy module mapping.



  ## Examples

      ToolParserManager.register_lazy_module(
      name="kimi_k2",
      module_path="vllm.tool_parsers.kimi_k2_parser",
      class_name="KimiK2ToolParser",
      )

  ## Parameters

  - `name` (String.t())
  - `module_path` (String.t())
  - `class_name` (String.t())

  ## Returns

  - `nil`
  """
  @spec register_lazy_module(SnakeBridge.Ref.t(), String.t(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def register_lazy_module(ref, name, module_path, class_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :register_lazy_module,
      [name, module_path, class_name],
      opts
    )
  end

  @doc """
  Register module immediately or lazily (as a decorator).

  Usage:
      @ToolParserManager.register_module("kimi_k2")
      class KimiK2ToolParser(ToolParser):
          ...

  Or:
      ToolParserManager.register_module(module=SomeToolParser)

  ## Parameters

  - `name` (term() default: None)
  - `force` (boolean() default: True)
  - `module` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec register_module(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def register_module(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :register_module, [] ++ List.wrap(args), opts)
  end

  @spec lazy_parsers(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lazy_parsers(ref) do
    SnakeBridge.Runtime.get_attr(ref, :lazy_parsers)
  end

  @spec tool_parsers(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tool_parsers(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tool_parsers)
  end
end
