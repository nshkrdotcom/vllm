# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.collect_env

defmodule Vllm.CollectEnv do
  @moduledoc """
  Submodule bindings for `vllm.collect_env`.

  ## Version

  - Requested: 0.14.0
  - Observed at generation: 0.14.0

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Vllm.CollectEnv.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Vllm.CollectEnv.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Vllm.CollectEnv.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Vllm.CollectEnv.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "vllm.collect_env"
  @doc false
  def __snakebridge_library__, do: "vllm"

  @doc """
  Python binding for `vllm.collect_env.check_release_file`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec check_release_file(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def check_release_file(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :check_release_file, [run_lambda], opts)
  end

  @doc """
  set() -> new empty set object

  set(iterable) -> new set object

  Build an unordered collection of unique elements.

  ## Returns

  - `MapSet.t(term())`
  """
  @spec default_conda_patterns() :: {:ok, MapSet.t(term())} | {:error, Snakepit.Error.t()}
  def default_conda_patterns() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "DEFAULT_CONDA_PATTERNS")
  end

  @doc """
  set() -> new empty set object

  set(iterable) -> new set object

  Build an unordered collection of unique elements.

  ## Returns

  - `MapSet.t(term())`
  """
  @spec default_pip_patterns() :: {:ok, MapSet.t(term())} | {:error, Snakepit.Error.t()}
  def default_pip_patterns() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "DEFAULT_PIP_PATTERNS")
  end

  @doc """
  str(object='') -> str

  str(bytes_or_buffer[, encoding[, errors]]) -> str

  Create a new string object from the given object. If encoding or
  errors is specified, then the object must expose a data buffer
  that will be decoded using the given encoding and error handler.
  Otherwise, returns the result of object.__str__() (if defined)
  or repr(object).
  encoding defaults to sys.getdefaultencoding().
  errors defaults to 'strict'.

  ## Returns

  - `String.t()`
  """
  @spec env_info_fmt() :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def env_info_fmt() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :env_info_fmt)
  end

  @doc """
  dict() -> new empty dictionary

  dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
  dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
  dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)

  ## Returns

  - `%{optional(term()) => term()}`
  """
  @spec environment_variables() ::
          {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
  def environment_variables() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :environment_variables)
  end

  @doc """
  Python binding for `vllm.collect_env.get_cachingallocator_config`.

  ## Returns

  - `term()`
  """
  @spec get_cachingallocator_config(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cachingallocator_config(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_cachingallocator_config, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_clang_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_clang_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_clang_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_clang_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_cmake_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_cmake_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cmake_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_cmake_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_conda_packages`.

  ## Parameters

  - `run_lambda` (term())
  - `patterns` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec get_conda_packages(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_conda_packages(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_conda_packages(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_conda_packages(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_conda_packages(run_lambda) do
    SnakeBridge.Runtime.call(__MODULE__, :get_conda_packages, [run_lambda], [])
  end

  def get_conda_packages(run_lambda, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :get_conda_packages, [run_lambda], opts)
  end

  def get_conda_packages(run_lambda, patterns) do
    SnakeBridge.Runtime.call(__MODULE__, :get_conda_packages, [run_lambda, patterns], [])
  end

  def get_conda_packages(run_lambda, patterns, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :get_conda_packages, [run_lambda, patterns], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_cpu_info`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_cpu_info(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cpu_info(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_cpu_info, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_cuda_module_loading_config`.

  ## Returns

  - `term()`
  """
  @spec get_cuda_module_loading_config(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cuda_module_loading_config(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_cuda_module_loading_config, [], opts)
  end

  @doc """
  Return a list of libcudnn.so; it's hard to tell which one is being used.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_cudnn_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_cudnn_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_cudnn_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_env_info`.

  ## Returns

  - `term()`
  """
  @spec get_env_info(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_env_info(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_env_info, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_env_vars`.

  ## Returns

  - `term()`
  """
  @spec get_env_vars(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_env_vars(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_env_vars, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_gcc_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_gcc_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_gcc_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_gcc_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_gpu_info`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_gpu_info(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_gpu_info(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_gpu_info, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_gpu_topo`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_gpu_topo(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_gpu_topo(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_gpu_topo, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_libc_version`.

  ## Returns

  - `term()`
  """
  @spec get_libc_version(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_libc_version(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_libc_version, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_lsb_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_lsb_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_lsb_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_lsb_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_mac_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_mac_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_mac_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_mac_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_nvidia_driver_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_nvidia_driver_version(term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_nvidia_driver_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_nvidia_driver_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_nvidia_smi`.

  ## Returns

  - `term()`
  """
  @spec get_nvidia_smi(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_nvidia_smi(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_nvidia_smi, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_os`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_os(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_os(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_os, [run_lambda], opts)
  end

  @doc """
  Return `pip list` output. Note: will also find conda-installed pytorch and numpy packages.

  ## Parameters

  - `run_lambda` (term())
  - `patterns` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec get_pip_packages(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_pip_packages(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_pip_packages(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec get_pip_packages(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_pip_packages(run_lambda) do
    SnakeBridge.Runtime.call(__MODULE__, :get_pip_packages, [run_lambda], [])
  end

  def get_pip_packages(run_lambda, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :get_pip_packages, [run_lambda], opts)
  end

  def get_pip_packages(run_lambda, patterns) do
    SnakeBridge.Runtime.call(__MODULE__, :get_pip_packages, [run_lambda, patterns], [])
  end

  def get_pip_packages(run_lambda, patterns, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :get_pip_packages, [run_lambda, patterns], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_platform`.

  ## Returns

  - `term()`
  """
  @spec get_platform(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_platform(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_platform, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_pretty_env_info`.

  ## Returns

  - `term()`
  """
  @spec get_pretty_env_info(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_pretty_env_info(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_pretty_env_info, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_python_platform`.

  ## Returns

  - `term()`
  """
  @spec get_python_platform(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_python_platform(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_python_platform, [], opts)
  end

  @doc """
  Returns the ROCm version if available, otherwise 'N/A'.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_rocm_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_rocm_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_rocm_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_running_cuda_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_running_cuda_version(term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_running_cuda_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_running_cuda_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_vllm_version`.

  ## Returns

  - `term()`
  """
  @spec get_vllm_version(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_vllm_version(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_vllm_version, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.get_windows_version`.

  ## Parameters

  - `run_lambda` (term())

  ## Returns

  - `term()`
  """
  @spec get_windows_version(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_windows_version(run_lambda, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :get_windows_version, [run_lambda], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.is_uv_venv`.

  ## Returns

  - `term()`
  """
  @spec is_uv_venv(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_uv_venv(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :is_uv_venv, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.is_xnnpack_available`.

  ## Returns

  - `term()`
  """
  @spec is_xnnpack_available(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_xnnpack_available(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :is_xnnpack_available, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.main`.

  ## Returns

  - `term()`
  """
  @spec main(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def main(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :main, [], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.pretty_str`.

  ## Parameters

  - `envinfo` (term())

  ## Returns

  - `term()`
  """
  @spec pretty_str(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def pretty_str(envinfo, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :pretty_str, [envinfo], opts)
  end

  @doc """
  Return (return-code, stdout, stderr).

  ## Parameters

  - `command` (term())

  ## Returns

  - `term()`
  """
  @spec run(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def run(command, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :run, [command], opts)
  end

  @doc """
  Run command using run_lambda, returns the first regex match if it exists.

  ## Parameters

  - `run_lambda` (term())
  - `command` (term())
  - `regex` (term())

  ## Returns

  - `term()`
  """
  @spec run_and_parse_first_match(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def run_and_parse_first_match(run_lambda, command, regex, opts \\ []) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :run_and_parse_first_match,
      [run_lambda, command, regex],
      opts
    )
  end

  @doc """
  Run command using run_lambda; reads and returns entire output if rc is 0.

  ## Parameters

  - `run_lambda` (term())
  - `command` (term())

  ## Returns

  - `term()`
  """
  @spec run_and_read_all(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def run_and_read_all(run_lambda, command, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :run_and_read_all, [run_lambda, command], opts)
  end

  @doc """
  Run command using run_lambda and returns first line if output is not empty.

  ## Parameters

  - `run_lambda` (term())
  - `command` (term())

  ## Returns

  - `term()`
  """
  @spec run_and_return_first_line(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def run_and_return_first_line(run_lambda, command, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :run_and_return_first_line, [run_lambda, command], opts)
  end

  @doc """
  Python binding for `vllm.collect_env.summarize_vllm_build_flags`.

  ## Returns

  - `term()`
  """
  @spec summarize_vllm_build_flags(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def summarize_vllm_build_flags(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :summarize_vllm_build_flags, [], opts)
  end

  @doc """
  bool(x) -> bool

  Returns True when the argument x is true, False otherwise.
  The builtins True and False are the only two instances of the class bool.
  The class bool is a subclass of the class int, and cannot be subclassed.

  ## Returns

  - `boolean()`
  """
  @spec torch_available() :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def torch_available() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "TORCH_AVAILABLE")
  end
end
