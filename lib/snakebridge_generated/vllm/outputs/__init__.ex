# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.outputs

defmodule Vllm.Outputs do
  @moduledoc """
  Submodule bindings for `vllm.outputs`.

  ## Version

  - Requested: 0.14.0
  - Observed at generation: 0.14.0

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Vllm.Outputs.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Vllm.Outputs.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Vllm.Outputs.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Vllm.Outputs.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "vllm.outputs"
  @doc false
  def __snakebridge_library__, do: "vllm"

  @doc """
  Type variable.

  The preferred way to construct a type variable is via the dedicated
  syntax for generic functions, classes, and type aliases::

    class Sequence[T]:  # T is a TypeVar
        ...

  This syntax can also be used to create bound and constrained type
  variables::

    # S is a TypeVar bound to str
    class StrSequence[S: str]:
        ...

    # A is a TypeVar constrained to str or bytes
    class StrOrBytesSequence[A: (str, bytes)]:
        ...

  However, if desired, reusable type variables can also be constructed
  manually, like so::

   T = TypeVar('T')  # Can be anything
   S = TypeVar('S', bound=str)  # Can be any subtype of str
   A = TypeVar('A', str, bytes)  # Must be exactly str or bytes

  Type variables exist primarily for the benefit of static type
  checkers.  They serve as the parameters for generic types as well
  as for generic function and type alias definitions.

  The variance of type variables is inferred by type checkers when they
  are created through the type parameter syntax and when
  ``infer_variance=True`` is passed. Manually created type variables may
  be explicitly marked covariant or contravariant by passing
  ``covariant=True`` or ``contravariant=True``. By default, manually
  created type variables are invariant. See PEP 484 and PEP 695 for more
  details.

  ## Returns

  - `term()`
  """
  @spec _o() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _o() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "_O")
  end

  @doc """
  Instances of the Logger class represent a single logging channel. A

  "logging channel" indicates an area of an application. Exactly how an
  "area" is defined is up to the application developer. Since an
  application can have any number of areas, logging channels are identified
  by a unique string. Application areas can be nested (e.g. an area
  of "input processing" might include sub-areas "read CSV files", "read
  XLS files" and "read Gnumeric files"). To cater for this natural nesting,
  channel names are organized into a namespace hierarchy where levels are
  separated by periods, much like the Java or Python package namespace. So
  in the instance given above, channel names might be "input" for the upper
  level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.
  There is no arbitrary limit to the depth of nesting.

  ## Returns

  - `term()`
  """
  @spec logger() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logger() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :logger)
  end

  @doc """
  Python binding for `vllm.outputs.STREAM_FINISHED`.

  ## Returns

  - `term()`
  """
  @spec stream_finished() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec stream_finished(term(), term(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def stream_finished() do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [], [])
  end

  def stream_finished(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [], opts)
  end

  def stream_finished(arg1) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1], [])
  end

  def stream_finished(arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1], opts)
  end

  def stream_finished(arg1, arg2) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2], [])
  end

  def stream_finished(arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2], opts)
  end

  def stream_finished(arg1, arg2, arg3) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3], [])
  end

  def stream_finished(arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3], opts)
  end

  def stream_finished(arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3, arg4], [])
  end

  def stream_finished(arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3, arg4], opts)
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3, arg4, arg5], [])
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, "STREAM_FINISHED", [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6],
      []
    )
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6],
      opts
    )
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def stream_finished(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      "STREAM_FINISHED",
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end
end
