# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.logprobs
# Python class: FlatLogprobs

defmodule Vllm.Logprobs.FlatLogprobs do
  @moduledoc """
  Flat logprobs of a request into multiple primitive type lists.

  Compared to list[dict[int, Logprob]], this data structure reduced GC
  overhead significantly. As it flattened logprob information for
  all positions and ranks in to multiple primitive type lists (i.e.
  logprobs, token_ids, ranks per token_ids, decoded_tokens).
  So regardless of the sequence length and top_logprobs setup,
  FlatLogprobs would only introduce a constant amount of objects.

  As each position might contains different amount of ranks,
  start_indices_per_position would be used to access the logprob ranges
  for different positions.

  NOTE: To reduce the migration overhead and improve backward compatibility,
  we support the key Sequence APIs of list, so it could act as
  list[LogprobsOnePosition]
  """
  def __snakebridge_python_name__, do: "vllm.logprobs"
  def __snakebridge_python_class__, do: "FlatLogprobs"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `start_indices` (list(integer()) default: <factory>)
  - `end_indices` (list(integer()) default: <factory>)
  - `token_ids` (list(integer()) default: <factory>)
  - `logprobs` (list(float()) default: <factory>)
  - `ranks` (list(term()) default: <factory>)
  - `decoded_tokens` (list(term()) default: <factory>)
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Appends the container with logprobs for the next position

  ## Parameters

  - `logprobs_one_position` (term())

  ## Returns

  - `nil`
  """
  @spec append(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def append(ref, logprobs_one_position, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :append, [logprobs_one_position], opts)
  end

  @doc """
  Appends logprobs for the next position without creating

  the intermediate logprob dictionary.

  ## Parameters

  - `token_ids` (list(integer()))
  - `logprobs` (list(float()))
  - `ranks` (term())
  - `decoded_tokens` (term())

  ## Returns

  - `nil`
  """
  @spec append_fast(
          SnakeBridge.Ref.t(),
          list(integer()),
          list(float()),
          term(),
          term(),
          keyword()
        ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def append_fast(ref, token_ids, logprobs, ranks, decoded_tokens, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :append_fast,
      [token_ids, logprobs, ranks, decoded_tokens],
      opts
    )
  end

  @doc """
  S.clear() -> None -- remove all items from S

  ## Returns

  - `term()`
  """
  @spec clear(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def clear(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :clear, [], opts)
  end

  @doc """
  S.count(value) -> integer -- return number of occurrences of value

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec count(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def count(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :count, [value], opts)
  end

  @doc """
  Extends the container with logprobs for the next multiple positions

  ## Parameters

  - `logprobs_multi_positions` (term())

  ## Returns

  - `nil`
  """
  @spec extend(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def extend(ref, logprobs_multi_positions, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extend, [logprobs_multi_positions], opts)
  end

  @doc """
  S.index(value, [start, [stop]]) -> integer -- return first index of value.

  Raises ValueError if the value is not present.

  Supporting start and stop arguments is optional, but
  recommended.

  ## Parameters

  - `value` (term())
  - `start` (term() default: 0)
  - `stop` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec index(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def index(ref, value, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :index, [value] ++ List.wrap(args), opts)
  end

  @doc """
  S.insert(index, value) -- insert value before index

  ## Parameters

  - `item` (term())

  ## Returns

  - `nil`
  """
  @spec insert(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def insert(ref, item, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :insert, [item], opts)
  end

  @doc """
  S.pop([index]) -> item -- remove and return item at index (default last).

  Raise IndexError if list is empty or index is out of range.

  ## Parameters

  - `index` (term() default: -1)

  ## Returns

  - `term()`
  """
  @spec pop(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def pop(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :pop, [] ++ List.wrap(args), opts)
  end

  @doc """
  S.remove(value) -- remove first occurrence of value.

  Raise ValueError if the value is not present.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec remove(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def remove(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :remove, [value], opts)
  end

  @doc """
  S.reverse() -- reverse *IN PLACE*

  ## Returns

  - `term()`
  """
  @spec reverse(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reverse(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :reverse, [], opts)
  end

  @spec _abc_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _abc_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_abc_impl)
  end
end
