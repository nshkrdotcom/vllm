# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.model_executor
# Python class: BasevLLMParameter

defmodule Vllm.ModelExecutor.BasevLLMParameter do
  @moduledoc """
  Base parameter for vLLM linear layers. Extends the torch.nn.parameter

  by taking in a linear weight loader. Will copy the loaded weight
  into the parameter when the provided weight loader is called.
  """
  def __snakebridge_python_name__, do: "vllm.model_executor"
  def __snakebridge_python_class__, do: "BasevLLMParameter"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize the BasevLLMParameter



  ## Parameters

  - `data` - torch tensor with the parameter data
  - `weight_loader` - weight loader callable

  ## Returns

   a torch.nn.parameter
  """
  @spec new(term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(data, weight_loader, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [data, weight_loader], opts)
  end

  @doc """
  Python method `BasevLLMParameter._assert_and_load`.

  ## Parameters

  - `loaded_weight` (term())

  ## Returns

  - `term()`
  """
  @spec _assert_and_load(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _assert_and_load(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_assert_and_load, [loaded_weight], opts)
  end

  @doc """
  Python method `BasevLLMParameter._is_1d_and_scalar`.

  ## Parameters

  - `loaded_weight` (term())

  ## Returns

  - `term()`
  """
  @spec _is_1d_and_scalar(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _is_1d_and_scalar(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_is_1d_and_scalar, [loaded_weight], opts)
  end

  @doc """
  Python method `BasevLLMParameter._shard_id_as_int`.

  ## Parameters

  - `shard_id` (term())

  ## Returns

  - `integer()`
  """
  @spec _shard_id_as_int(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def _shard_id_as_int(ref, shard_id, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_shard_id_as_int, [shard_id], opts)
  end

  @doc """
  Python method `BasevLLMParameter.load_column_parallel_weight`.

  ## Parameters

  - `loaded_weight` (term())

  ## Returns

  - `term()`
  """
  @spec load_column_parallel_weight(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_column_parallel_weight(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_column_parallel_weight, [loaded_weight], opts)
  end

  @doc """
  Python method `BasevLLMParameter.load_merged_column_weight`.

  ## Parameters

  - `loaded_weight` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec load_merged_column_weight(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_merged_column_weight(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_merged_column_weight, [loaded_weight], opts)
  end

  @doc """
  Python method `BasevLLMParameter.load_qkv_weight`.

  ## Parameters

  - `loaded_weight` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec load_qkv_weight(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_qkv_weight(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_qkv_weight, [loaded_weight], opts)
  end

  @doc """
  Python method `BasevLLMParameter.load_row_parallel_weight`.

  ## Parameters

  - `loaded_weight` (term())

  ## Returns

  - `term()`
  """
  @spec load_row_parallel_weight(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def load_row_parallel_weight(ref, loaded_weight, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :load_row_parallel_weight, [loaded_weight], opts)
  end

  @spec h(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def h(ref) do
    SnakeBridge.Runtime.get_attr(ref, :H)
  end

  @spec t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :T)
  end

  @spec _backward_hooks(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _backward_hooks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_backward_hooks)
  end

  @spec _base(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _base(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_base)
  end

  @spec _cdata(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _cdata(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_cdata)
  end

  @spec _grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_grad)
  end

  @spec _grad_fn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _grad_fn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_grad_fn)
  end

  @spec _has_symbolic_sizes_strides(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _has_symbolic_sizes_strides(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_has_symbolic_sizes_strides)
  end

  @spec _post_accumulate_grad_hooks(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _post_accumulate_grad_hooks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_post_accumulate_grad_hooks)
  end

  @spec _python_dispatch(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _python_dispatch(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_python_dispatch)
  end

  @spec _version(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _version(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_version)
  end

  @spec data(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data)
  end

  @spec device(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def device(ref) do
    SnakeBridge.Runtime.get_attr(ref, :device)
  end

  @spec dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dtype)
  end

  @spec grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :grad)
  end

  @spec grad_fn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grad_fn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :grad_fn)
  end

  @spec imag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def imag(ref) do
    SnakeBridge.Runtime.get_attr(ref, :imag)
  end

  @spec is_cpu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_cpu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_cpu)
  end

  @spec is_cuda(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_cuda(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_cuda)
  end

  @spec is_ipu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_ipu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_ipu)
  end

  @spec is_leaf(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_leaf(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_leaf)
  end

  @spec is_maia(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_maia(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_maia)
  end

  @spec is_meta(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_meta(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_meta)
  end

  @spec is_mkldnn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mkldnn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mkldnn)
  end

  @spec is_mps(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mps(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mps)
  end

  @spec is_mtia(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mtia(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mtia)
  end

  @spec is_nested(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_nested(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_nested)
  end

  @spec is_quantized(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_quantized(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_quantized)
  end

  @spec is_sparse(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_sparse(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_sparse)
  end

  @spec is_sparse_csr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_sparse_csr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_sparse_csr)
  end

  @spec is_vulkan(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_vulkan(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_vulkan)
  end

  @spec is_xla(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_xla(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_xla)
  end

  @spec is_xpu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_xpu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_xpu)
  end

  @spec itemsize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def itemsize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :itemsize)
  end

  @spec layout(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def layout(ref) do
    SnakeBridge.Runtime.get_attr(ref, :layout)
  end

  @spec m_h(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def m_h(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mH)
  end

  @spec m_t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def m_t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mT)
  end

  @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def name(ref) do
    SnakeBridge.Runtime.get_attr(ref, :name)
  end

  @spec names(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def names(ref) do
    SnakeBridge.Runtime.get_attr(ref, :names)
  end

  @spec nbytes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nbytes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nbytes)
  end

  @spec ndim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ndim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ndim)
  end

  @spec output_nr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_nr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_nr)
  end

  @spec real(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def real(ref) do
    SnakeBridge.Runtime.get_attr(ref, :real)
  end

  @spec requires_grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def requires_grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :requires_grad)
  end

  @spec retains_grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def retains_grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :retains_grad)
  end

  @spec shape(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def shape(ref) do
    SnakeBridge.Runtime.get_attr(ref, :shape)
  end

  @spec volatile(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def volatile(ref) do
    SnakeBridge.Runtime.get_attr(ref, :volatile)
  end

  @spec weight_loader(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def weight_loader(ref) do
    SnakeBridge.Runtime.get_attr(ref, :weight_loader)
  end
end
