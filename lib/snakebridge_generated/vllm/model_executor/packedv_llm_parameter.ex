# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.model_executor
# Python class: PackedvLLMParameter

defmodule Vllm.ModelExecutor.PackedvLLMParameter do
  @moduledoc """
  Parameter for model weights which are packed on disk.

  Example: GPTQ Marlin weights are int4 or int8, packed into int32.
  Extends the ModelWeightParameter to take in the
  packed factor, the packed dimension, and optionally, marlin
  tile size for marlin kernels. Adjusts the shard_size and
  shard_offset for fused linear layers model weight loading
  by accounting for packing and optionally, marlin tile size.
  """
  def __snakebridge_python_name__, do: "vllm.model_executor"
  def __snakebridge_python_class__, do: "PackedvLLMParameter"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize the BasevLLMParameter



  ## Parameters

  - `data` - torch tensor with the parameter data
  - `weight_loader` - weight loader callable

  ## Returns

   a torch.nn.parameter
  """
  @spec new(term(), integer(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(packed_factor, packed_dim, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [packed_factor, packed_dim] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `PackedvLLMParameter.adjust_shard_indexes_for_packing`.

  ## Parameters

  - `shard_size` (term())
  - `shard_offset` (term())

  ## Returns

  - `term()`
  """
  @spec adjust_shard_indexes_for_packing(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def adjust_shard_indexes_for_packing(ref, shard_size, shard_offset, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :adjust_shard_indexes_for_packing,
      [shard_size, shard_offset],
      opts
    )
  end

  @spec h(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def h(ref) do
    SnakeBridge.Runtime.get_attr(ref, :H)
  end

  @spec t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :T)
  end

  @spec _backward_hooks(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _backward_hooks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_backward_hooks)
  end

  @spec _base(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _base(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_base)
  end

  @spec _cdata(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _cdata(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_cdata)
  end

  @spec _grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_grad)
  end

  @spec _grad_fn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _grad_fn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_grad_fn)
  end

  @spec _has_symbolic_sizes_strides(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _has_symbolic_sizes_strides(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_has_symbolic_sizes_strides)
  end

  @spec _post_accumulate_grad_hooks(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _post_accumulate_grad_hooks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_post_accumulate_grad_hooks)
  end

  @spec _python_dispatch(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _python_dispatch(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_python_dispatch)
  end

  @spec _version(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _version(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_version)
  end

  @spec bitblas_tile_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bitblas_tile_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :bitblas_tile_size)
  end

  @spec data(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data)
  end

  @spec device(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def device(ref) do
    SnakeBridge.Runtime.get_attr(ref, :device)
  end

  @spec dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dtype)
  end

  @spec grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :grad)
  end

  @spec grad_fn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grad_fn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :grad_fn)
  end

  @spec imag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def imag(ref) do
    SnakeBridge.Runtime.get_attr(ref, :imag)
  end

  @spec input_dim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def input_dim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :input_dim)
  end

  @spec is_cpu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_cpu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_cpu)
  end

  @spec is_cuda(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_cuda(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_cuda)
  end

  @spec is_ipu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_ipu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_ipu)
  end

  @spec is_leaf(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_leaf(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_leaf)
  end

  @spec is_maia(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_maia(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_maia)
  end

  @spec is_meta(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_meta(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_meta)
  end

  @spec is_mkldnn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mkldnn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mkldnn)
  end

  @spec is_mps(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mps(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mps)
  end

  @spec is_mtia(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mtia(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mtia)
  end

  @spec is_nested(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_nested(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_nested)
  end

  @spec is_quantized(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_quantized(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_quantized)
  end

  @spec is_sparse(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_sparse(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_sparse)
  end

  @spec is_sparse_csr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_sparse_csr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_sparse_csr)
  end

  @spec is_vulkan(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_vulkan(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_vulkan)
  end

  @spec is_xla(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_xla(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_xla)
  end

  @spec is_xpu(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_xpu(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_xpu)
  end

  @spec itemsize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def itemsize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :itemsize)
  end

  @spec layout(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def layout(ref) do
    SnakeBridge.Runtime.get_attr(ref, :layout)
  end

  @spec m_h(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def m_h(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mH)
  end

  @spec m_t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def m_t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mT)
  end

  @spec marlin_tile_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def marlin_tile_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :marlin_tile_size)
  end

  @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def name(ref) do
    SnakeBridge.Runtime.get_attr(ref, :name)
  end

  @spec names(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def names(ref) do
    SnakeBridge.Runtime.get_attr(ref, :names)
  end

  @spec nbytes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nbytes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nbytes)
  end

  @spec ndim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ndim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ndim)
  end

  @spec output_dim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_dim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_dim)
  end

  @spec output_nr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def output_nr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :output_nr)
  end

  @spec packed_dim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def packed_dim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :packed_dim)
  end

  @spec packed_factor(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def packed_factor(ref) do
    SnakeBridge.Runtime.get_attr(ref, :packed_factor)
  end

  @spec real(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def real(ref) do
    SnakeBridge.Runtime.get_attr(ref, :real)
  end

  @spec requires_grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def requires_grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :requires_grad)
  end

  @spec retains_grad(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def retains_grad(ref) do
    SnakeBridge.Runtime.get_attr(ref, :retains_grad)
  end

  @spec shape(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def shape(ref) do
    SnakeBridge.Runtime.get_attr(ref, :shape)
  end

  @spec volatile(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def volatile(ref) do
    SnakeBridge.Runtime.get_attr(ref, :volatile)
  end

  @spec weight_loader(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def weight_loader(ref) do
    SnakeBridge.Runtime.get_attr(ref, :weight_loader)
  end
end
