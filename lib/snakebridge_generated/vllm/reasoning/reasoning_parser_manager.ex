# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.reasoning
# Python class: ReasoningParserManager

defmodule Vllm.Reasoning.ReasoningParserManager do
  @moduledoc """
  Central registry for ReasoningParser implementations.

  Supports two registration modes:
    - Eager registration via `register_module`
    - Lazy registration via `register_lazy_module`

  Each reasoning parser must inherit from `ReasoningParser`.
  """
  def __snakebridge_python_name__, do: "vllm.reasoning"
  def __snakebridge_python_class__, do: "ReasoningParserManager"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Import and register a lazily loaded reasoning parser.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `term()`
  """
  @spec _load_lazy_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _load_lazy_parser(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_load_lazy_parser, [name], opts)
  end

  @doc """
  Register a ReasoningParser class immediately.

  ## Parameters

  - `module` (term())
  - `module_name` (term() default: None)
  - `force` (boolean() default: True)

  ## Returns

  - `nil`
  """
  @spec _register_module(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _register_module(ref, module, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :_register_module, [module] ++ List.wrap(args), opts)
  end

  @doc """
  Retrieve a registered or lazily registered ReasoningParser class.

  If the parser is lazily registered, it will be imported and cached
  on first access.

  ## Raises

  - `KeyError` - if no parser is found under the given name.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `term()`
  """
  @spec get_reasoning_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_reasoning_parser(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_reasoning_parser, [name], opts)
  end

  @doc """
  Import a user-defined reasoning parser by the path

  of the reasoning parser define file.

  ## Parameters

  - `plugin_path` (String.t())

  ## Returns

  - `nil`
  """
  @spec import_reasoning_parser(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def import_reasoning_parser(ref, plugin_path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :import_reasoning_parser, [plugin_path], opts)
  end

  @doc """
  Return names of all eagerly and lazily registered reasoning parsers.

  ## Returns

  - `list(String.t())`
  """
  @spec list_registered(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, list(String.t())} | {:error, Snakepit.Error.t()}
  def list_registered(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :list_registered, [], opts)
  end

  @doc """
  Register a lazy module mapping for delayed import.



  ## Examples

      ReasoningParserManager.register_lazy_module(
      name="qwen3",
      module_path="vllm.reasoning.parsers.qwen3_reasoning_parser",
      class_name="Qwen3ReasoningParser",
      )

  ## Parameters

  - `name` (String.t())
  - `module_path` (String.t())
  - `class_name` (String.t())

  ## Returns

  - `nil`
  """
  @spec register_lazy_module(SnakeBridge.Ref.t(), String.t(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def register_lazy_module(ref, name, module_path, class_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :register_lazy_module,
      [name, module_path, class_name],
      opts
    )
  end

  @doc """
  Register module with the given name or name list. it can be used as a

  decoder(with module as None) or normal function(with module as not
  None).

  ## Parameters

  - `name` (term() default: None)
  - `force` (boolean() default: True)
  - `module` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec register_module(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def register_module(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :register_module, [] ++ List.wrap(args), opts)
  end

  @spec lazy_parsers(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lazy_parsers(ref) do
    SnakeBridge.Runtime.get_attr(ref, :lazy_parsers)
  end

  @spec reasoning_parsers(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reasoning_parsers(ref) do
    SnakeBridge.Runtime.get_attr(ref, :reasoning_parsers)
  end
end
