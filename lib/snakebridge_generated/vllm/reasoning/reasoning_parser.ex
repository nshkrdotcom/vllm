# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.reasoning
# Python class: ReasoningParser

defmodule Vllm.Reasoning.ReasoningParser do
  @moduledoc """
  Abstract reasoning parser class that should not be used directly.

  Provided and methods should be used in derived classes.

  It is used to extract reasoning content from the model output.
  """
  def __snakebridge_python_name__, do: "vllm.reasoning"
  def __snakebridge_python_class__, do: "ReasoningParser"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `tokenizer` (term())
  """
  @spec new(term(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(tokenizer, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [tokenizer], opts)
  end

  @doc """
  Extract content token ids from the input_ids.

  Parameters:
  input_ids: list[int]
      The input_ids of the model output.

  ## Parameters

  - `input_ids` (list(integer()))

  ## Returns

  - `list(integer())`
  """
  @spec extract_content_ids(SnakeBridge.Ref.t(), list(integer()), keyword()) ::
          {:ok, list(integer())} | {:error, Snakepit.Error.t()}
  def extract_content_ids(ref, input_ids, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extract_content_ids, [input_ids], opts)
  end

  @doc """
  Extract reasoning content from a complete model-generated string.

  Used for non-streaming responses where we have the entire model response
  available before sending to the client.

  Parameters:
  model_output: str
      The model-generated string to extract reasoning content from.

  request: ChatCompletionRequest
      The request object that was used to generate the model_output.

  ## Parameters

  - `model_output` (String.t())
  - `request` (term())

  ## Returns

  - `{term(), term()}`
  """
  @spec extract_reasoning(SnakeBridge.Ref.t(), String.t(), term(), keyword()) ::
          {:ok, {term(), term()}} | {:error, Snakepit.Error.t()}
  def extract_reasoning(ref, model_output, request, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :extract_reasoning, [model_output, request], opts)
  end

  @doc """
  Instance method that should be implemented for extracting reasoning

  from an incomplete response; for use when handling reasoning calls and
  streaming. Has to be an instance method because  it requires state -
  the current tokens/diffs, but also the information about what has
  previously been parsed and extracted (see constructor)

  ## Parameters

  - `previous_text` (String.t())
  - `current_text` (String.t())
  - `delta_text` (String.t())
  - `previous_token_ids` (term())
  - `current_token_ids` (term())
  - `delta_token_ids` (term())

  ## Returns

  - `term()`
  """
  @spec extract_reasoning_streaming(
          SnakeBridge.Ref.t(),
          String.t(),
          String.t(),
          String.t(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def extract_reasoning_streaming(
        ref,
        previous_text,
        current_text,
        delta_text,
        previous_token_ids,
        current_token_ids,
        delta_token_ids,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :extract_reasoning_streaming,
      [
        previous_text,
        current_text,
        delta_text,
        previous_token_ids,
        current_token_ids,
        delta_token_ids
      ],
      opts
    )
  end

  @doc """
  Check if the reasoning content ends in the input_ids.

  It is used in structured engines like `xgrammar` to check if the
  reasoning content ends in the model output.

  Parameters:
  input_ids: list[int]
      The input_ids of the model output.

  ## Parameters

  - `input_ids` (list(integer()))

  ## Returns

  - `boolean()`
  """
  @spec is_reasoning_end(SnakeBridge.Ref.t(), list(integer()), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_reasoning_end(ref, input_ids, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_reasoning_end, [input_ids], opts)
  end

  @doc """
  Check if the reasoning content ends in the input_ids on a

  decode step.

  It is used in structured engines like `xgrammar` to check if the
  reasoning content ends in the model output during a decode step.
  `input_ids` the entire model output and `delta_ids` are the last few
  computed tokens of the model output (like during a decode step).

  Parameters:
  input_ids: list[int]
      The entire model output.
  delta_ids: list[int]
      The last few computed tokens of the model output at the current decode step.

  ## Parameters

  - `input_ids` (list(integer()))
  - `delta_ids` (list(integer()))

  ## Returns

  - `boolean()`
  """
  @spec is_reasoning_end_streaming(
          SnakeBridge.Ref.t(),
          list(integer()),
          list(integer()),
          keyword()
        ) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_reasoning_end_streaming(ref, input_ids, delta_ids, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :is_reasoning_end_streaming,
      [input_ids, delta_ids],
      opts
    )
  end

  @doc """
  Instance method that is implemented for preparing the structured tag

  Otherwise, None is returned

  ## Parameters

  - `original_tag` (term())
  - `tool_server` (term())

  ## Returns

  - `term()`
  """
  @spec prepare_structured_tag(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def prepare_structured_tag(ref, original_tag, tool_server, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :prepare_structured_tag,
      [original_tag, tool_server],
      opts
    )
  end

  @spec vocab(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def vocab(ref) do
    SnakeBridge.Runtime.get_attr(ref, :vocab)
  end
end
