# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.exceptions
# Python class: VLLMValidationError

defmodule Vllm.Exceptions.VLLMValidationError do
  @moduledoc """
  vLLM-specific validation error for request validation failures.



  ## Parameters

  - `message` - The error message describing the validation failure.
  - `parameter` - Optional parameter name that failed validation.
  - `value` - Optional value that was rejected during validation.
  """
  def __snakebridge_python_name__, do: "vllm.exceptions"
  def __snakebridge_python_class__, do: "VLLMValidationError"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `message` (String.t())
  - `parameter` (term() keyword-only default: None)
  - `value` (term() keyword-only default: None)
  """
  @spec new(String.t(), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(message, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [message], opts)
  end

  @doc """
  Exception.add_note(note) --

  add a note to the exception

  ## Returns

  - `term()`
  """
  @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def add_note(ref) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
  end

  def add_note(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
  end

  def add_note(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
  end

  def add_note(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
  end

  def add_note(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
  end

  def add_note(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
  end

  def add_note(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
  end

  def add_note(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Exception.with_traceback(tb) --

  set self.__traceback__ to tb and return self.

  ## Returns

  - `term()`
  """
  @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_traceback(ref) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
  end

  def with_traceback(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
  end

  def with_traceback(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
  end

  def with_traceback(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
  end

  def with_traceback(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
  end

  def with_traceback(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      opts
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def args(ref) do
    SnakeBridge.Runtime.get_attr(ref, :args)
  end
end
