# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.logger

defmodule Vllm.Logger do
  @moduledoc """
  Logging configuration for vLLM.

  ## Version

  - Requested: 0.14.0
  - Observed at generation: 0.14.0

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Vllm.Logger.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Vllm.Logger.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Vllm.Logger.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Vllm.Logger.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "vllm.logger"
  @doc false
  def __snakebridge_library__, do: "vllm"

  @doc """
  Logging configuration for vLLM.

  ## Returns

  - `nil`
  """
  @spec _configure_vllm_root_logger(keyword()) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def _configure_vllm_root_logger(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_configure_vllm_root_logger, [], opts)
  end

  @doc """
  Python module attribute `vllm.logger._DATE_FORMAT`.

  ## Returns

  - `String.t()`
  """
  @spec _date_format() :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _date_format() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "_DATE_FORMAT")
  end

  @doc """
  Python module attribute `vllm.logger._FORMAT`.

  ## Returns

  - `String.t()`
  """
  @spec _format() :: {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _format() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "_FORMAT")
  end

  @doc """
  Python module attribute `vllm.logger._METHODS_TO_PATCH`.

  ## Returns

  - `%{optional(term()) => term()}`
  """
  @spec _methods_to_patch() :: {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
  def _methods_to_patch() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "_METHODS_TO_PATCH")
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `logger` (term())
  - `msg` (String.t())
  - `args` (term())

  ## Returns

  - `nil`
  """
  @spec _print_debug_once(term(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _print_debug_once(logger, msg, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_print_debug_once, [logger, msg], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `logger` (term())
  - `msg` (String.t())
  - `args` (term())

  ## Returns

  - `nil`
  """
  @spec _print_info_once(term(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _print_info_once(logger, msg, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_print_info_once, [logger, msg], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `logger` (term())
  - `msg` (String.t())
  - `args` (term())

  ## Returns

  - `nil`
  """
  @spec _print_warning_once(term(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _print_warning_once(logger, msg, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_print_warning_once, [logger, msg], opts)
  end

  @doc """
  Decide whether to log based on scope

  ## Parameters

  - `scope` (term())

  ## Returns

  - `boolean()`
  """
  @spec _should_log_with_scope(term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _should_log_with_scope(scope, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_should_log_with_scope, [scope], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `log_path` (term())
  - `root_dir` (term())
  - `frame` (term())
  - `event` (term())
  - `arg` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec _trace_calls(term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _trace_calls(term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _trace_calls(term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec _trace_calls(term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _trace_calls(log_path, root_dir, frame, event) do
    SnakeBridge.Runtime.call(__MODULE__, :_trace_calls, [log_path, root_dir, frame, event], [])
  end

  def _trace_calls(log_path, root_dir, frame, event, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :_trace_calls, [log_path, root_dir, frame, event], opts)
  end

  def _trace_calls(log_path, root_dir, frame, event, arg) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_trace_calls,
      [log_path, root_dir, frame, event, arg],
      []
    )
  end

  def _trace_calls(log_path, root_dir, frame, event, arg, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :_trace_calls,
      [log_path, root_dir, frame, event, arg],
      opts
    )
  end

  @doc """
  Logging configuration for vLLM.

  ## Returns

  - `boolean()`
  """
  @spec _use_color(keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def _use_color(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :_use_color, [], opts)
  end

  @doc """
  Python binding for `vllm.logger.current_formatter_type`.

  ## Returns

  - `term()`
  """
  @spec current_formatter_type() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(term(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec current_formatter_type(
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def current_formatter_type() do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [], [])
  end

  def current_formatter_type(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [], opts)
  end

  def current_formatter_type(arg1) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1], [])
  end

  def current_formatter_type(arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1], opts)
  end

  def current_formatter_type(arg1, arg2) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2], [])
  end

  def current_formatter_type(arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2], opts)
  end

  def current_formatter_type(arg1, arg2, arg3) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2, arg3], [])
  end

  def current_formatter_type(arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2, arg3], opts)
  end

  def current_formatter_type(arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2, arg3, arg4], [])
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :current_formatter_type, [arg1, arg2, arg3, arg4], opts)
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5],
      []
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5],
      opts
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      []
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      opts
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def current_formatter_type(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :current_formatter_type,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Python module attribute `vllm.logger.DEFAULT_LOGGING_CONFIG`.

  ## Returns

  - `%{optional(term()) => term()}`
  """
  @spec default_logging_config() ::
          {:ok, %{optional(term()) => term()}} | {:error, Snakepit.Error.t()}
  def default_logging_config() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, "DEFAULT_LOGGING_CONFIG")
  end

  @doc """
  Enable tracing of every function call in code under `root_dir`.

  This is useful for debugging hangs or crashes.
  `log_file_path` is the path to the log file.
  `root_dir` is the root directory of the code to trace. If None, it is the
  vllm root directory.

  Note that this call is thread-level, any threads calling this function
  will have the trace enabled. Other threads will not be affected.

  ## Parameters

  - `log_file_path` (String.t())
  - `root_dir` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec enable_trace_function_call(String.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec enable_trace_function_call(String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec enable_trace_function_call(String.t(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec enable_trace_function_call(String.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_trace_function_call(log_file_path) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_trace_function_call, [log_file_path], [])
  end

  def enable_trace_function_call(log_file_path, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :enable_trace_function_call, [log_file_path], opts)
  end

  def enable_trace_function_call(log_file_path, root_dir) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :enable_trace_function_call,
      [log_file_path, root_dir],
      []
    )
  end

  def enable_trace_function_call(log_file_path, root_dir, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :enable_trace_function_call,
      [log_file_path, root_dir],
      opts
    )
  end

  @doc """
  The main purpose of this function is to ensure that loggers are

  retrieved in such a way that we can be sure the root vllm logger has
  already been configured.

  ## Parameters

  - `name` (String.t())

  ## Returns

  - `Vllm.Logger.VllmLogger.t()`
  """
  @spec init_logger(String.t(), keyword()) ::
          {:ok, Vllm.Logger.VllmLogger.t()} | {:error, Snakepit.Error.t()}
  def init_logger(name, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :init_logger, [name], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec log_scope(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def log_scope(opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, "LogScope", [], opts)
  end

  @doc """
  Python module attribute `vllm.logger.logger`.

  ## Returns

  - `term()`
  """
  @spec logger() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logger() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :logger)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `level` (integer() default: 20)

  ## Returns

  - `term()`
  """
  @spec suppress_logging() :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec suppress_logging(keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec suppress_logging(integer()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec suppress_logging(integer(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def suppress_logging() do
    SnakeBridge.Runtime.call(__MODULE__, :suppress_logging, [], [])
  end

  def suppress_logging(opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :suppress_logging, [], opts)
  end

  def suppress_logging(level) do
    SnakeBridge.Runtime.call(__MODULE__, :suppress_logging, [level], [])
  end

  def suppress_logging(level, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :suppress_logging, [level], opts)
  end
end
