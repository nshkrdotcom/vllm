# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.logger
# Python class: _VllmLogger

defmodule Vllm.Logger.VllmLogger do
  @moduledoc """
  Note:

  This class is just to provide type information.
      We actually patch the methods directly on the [`logging.Logger`][]
      instance to avoid conflicting with other libraries such as
      `intel_extension_for_pytorch.utils._logger`.
  """
  def __snakebridge_python_name__, do: "vllm.logger"
  def __snakebridge_python_class__, do: "_VllmLogger"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize the logger with a name and an optional level.

  ## Parameters

  - `name` (term())
  - `level` (term() default: 0)
  """
  @spec new(term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(name, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [name] ++ List.wrap(args), opts)
  end

  @doc """
  Low-level logging routine which creates a LogRecord and then calls

  all the handlers of this logger to handle the record.

  ## Parameters

  - `level` (term())
  - `msg` (term())
  - `args` (term())
  - `exc_info` (term() default: None)
  - `extra` (term() default: None)
  - `stack_info` (term() default: False)
  - `stacklevel` (term() default: 1)

  ## Returns

  - `term()`
  """
  @spec _log(SnakeBridge.Ref.t(), term(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _log(ref, level, msg, args, extra_args, opts \\ []) do
    {extra_args, opts} = SnakeBridge.Runtime.normalize_args_opts(extra_args, opts)
    SnakeBridge.Runtime.call_method(ref, :_log, [level, msg, args] ++ List.wrap(extra_args), opts)
  end

  @doc """
  Add the specified filter to this handler.

  ## Parameters

  - `filter` (term())

  ## Returns

  - `term()`
  """
  @spec add_filter(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def add_filter(ref, filter, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "addFilter", [filter], opts)
  end

  @doc """
  Add the specified handler to this logger.

  ## Parameters

  - `hdlr` (term())

  ## Returns

  - `term()`
  """
  @spec add_handler(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def add_handler(ref, hdlr, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "addHandler", [hdlr], opts)
  end

  @doc """
  Pass a record to all relevant handlers.

  Loop through all handlers for this logger and its parents in the
  logger hierarchy. If no handler was found, output a one-off error
  message to sys.stderr. Stop searching up the hierarchy whenever a
  logger with the "propagate" attribute set to zero is found - that
  will be the last logger whose handlers are called.

  ## Parameters

  - `record` (term())

  ## Returns

  - `term()`
  """
  @spec call_handlers(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def call_handlers(ref, record, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "callHandlers", [record], opts)
  end

  @doc """
  Log 'msg % args' with severity 'CRITICAL'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.critical("Houston, we have a %s", "major disaster", exc_info=True)

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec critical(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def critical(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :critical, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Log 'msg % args' with severity 'DEBUG'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.debug("Houston, we have a %s", "thorny problem", exc_info=True)

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec debug(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def debug(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :debug, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  As [`debug`][logging.Logger.debug], but subsequent calls with

  the same message are silently dropped.

  ## Parameters

  - `msg` (String.t())
  - `args` (term())
  - `scope` (term() keyword-only default: 'process')

  ## Returns

  - `nil`
  """
  @spec debug_once(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def debug_once(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :debug_once, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Log 'msg % args' with severity 'ERROR'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.error("Houston, we have a %s", "major problem", exc_info=True)

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec error(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def error(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :error, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Convenience method for logging an ERROR with exception information.

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `exc_info` (term() keyword-only default: True)
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec exception(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def exception(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :exception, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Don't use this method, use critical() instead.

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec fatal(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def fatal(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :fatal, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Determine if a record is loggable by consulting all the filters.

  The default is to allow the record to be logged; any filter can veto
  this by returning a false value.
  If a filter attached to a handler returns a log record instance,
  then that instance is used in place of the original log record in
  any further processing of the event by that handler.
  If a filter returns any other true value, the original log record
  is used in any further processing of the event by that handler.

  If none of the filters return false values, this method returns
  a log record.
  If any of the filters return a false value, this method returns
  a false value.

  .. versionchanged:: 3.2

     Allow filters to be just callables.

  .. versionchanged:: 3.12
     Allow filters to return a LogRecord instead of
     modifying it in place.

  ## Parameters

  - `record` (term())

  ## Returns

  - `term()`
  """
  @spec filter(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def filter(ref, record, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :filter, [record], opts)
  end

  @doc """
  Find the stack frame of the caller so that we can note the source

  file name, line number and function name.

  ## Parameters

  - `stack_info` (term() default: False)
  - `stacklevel` (term() default: 1)

  ## Returns

  - `term()`
  """
  @spec find_caller(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def find_caller(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, "findCaller", [] ++ List.wrap(args), opts)
  end

  @doc """
  Get a logger which is a descendant to this one.

  This is a convenience method, such that

  logging.getLogger('abc').getChild('def.ghi')

  is the same as

  logging.getLogger('abc.def.ghi')

  It's useful, for example, when the parent logger is named using
  __name__ rather than a literal string.

  ## Parameters

  - `suffix` (term())

  ## Returns

  - `term()`
  """
  @spec get_child(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_child(ref, suffix, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "getChild", [suffix], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Returns

  - `term()`
  """
  @spec get_children(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_children(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "getChildren", [], opts)
  end

  @doc """
  Get the effective level for this logger.

  Loop through this logger and its parents in the logger hierarchy,
  looking for a non-zero logging level. Return the first one found.

  ## Returns

  - `term()`
  """
  @spec get_effective_level(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_effective_level(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "getEffectiveLevel", [], opts)
  end

  @doc """
  Call the handlers for the specified record.

  This method is used for unpickled records received from a socket, as
  well as those created locally. Logger-level filtering is applied.

  ## Parameters

  - `record` (term())

  ## Returns

  - `term()`
  """
  @spec handle(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def handle(ref, record, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :handle, [record], opts)
  end

  @doc """
  See if this logger has any handlers configured.

  Loop through all handlers for this logger and its parents in the
  logger hierarchy. Return True if a handler was found, else False.
  Stop searching up the hierarchy whenever a logger with the "propagate"
  attribute set to zero is found - that will be the last logger which
  is checked for the existence of handlers.

  ## Returns

  - `term()`
  """
  @spec has_handlers(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def has_handlers(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "hasHandlers", [], opts)
  end

  @doc """
  Log 'msg % args' with severity 'INFO'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.info("Houston, we have a %s", "notable problem", exc_info=True)

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec info(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def info(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :info, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  As [`info`][logging.Logger.info], but subsequent calls with

  the same message are silently dropped.

  ## Parameters

  - `msg` (String.t())
  - `args` (term())
  - `scope` (term() keyword-only default: 'process')

  ## Returns

  - `nil`
  """
  @spec info_once(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def info_once(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :info_once, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Is this logger enabled for level 'level'?

  ## Parameters

  - `level` (term())

  ## Returns

  - `term()`
  """
  @spec is_enabled_for(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_enabled_for(ref, level, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "isEnabledFor", [level], opts)
  end

  @doc """
  Log 'msg % args' with the integer severity 'level'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.log(level, "We have a %s", "mysterious problem", exc_info=True)

  ## Parameters

  - `level` (term())
  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec log(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def log(ref, level, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :log, [level, msg] ++ List.wrap(args), opts)
  end

  @doc """
  A factory method which can be overridden in subclasses to create

  specialized LogRecords.

  ## Parameters

  - `name` (term())
  - `level` (term())
  - `py_fn` (term())
  - `lno` (term())
  - `msg` (term())
  - `args` (term())
  - `exc_info` (term())
  - `func` (term() default: None)
  - `extra` (term() default: None)
  - `sinfo` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec make_record(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          list(term()),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def make_record(ref, name, level, py_fn, lno, msg, args, exc_info, extra_args, opts \\ []) do
    {extra_args, opts} = SnakeBridge.Runtime.normalize_args_opts(extra_args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      "makeRecord",
      [name, level, py_fn, lno, msg, args, exc_info] ++ List.wrap(extra_args),
      opts
    )
  end

  @doc """
  Remove the specified filter from this handler.

  ## Parameters

  - `filter` (term())

  ## Returns

  - `term()`
  """
  @spec remove_filter(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def remove_filter(ref, filter, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "removeFilter", [filter], opts)
  end

  @doc """
  Remove the specified handler from this logger.

  ## Parameters

  - `hdlr` (term())

  ## Returns

  - `term()`
  """
  @spec remove_handler(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def remove_handler(ref, hdlr, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "removeHandler", [hdlr], opts)
  end

  @doc """
  Set the logging level of this logger.  level must be an int or a str.

  ## Parameters

  - `level` (term())

  ## Returns

  - `term()`
  """
  @spec set_level(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def set_level(ref, level, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "setLevel", [level], opts)
  end

  @doc """
  Logging configuration for vLLM.

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec warn(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def warn(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :warn, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  Log 'msg % args' with severity 'WARNING'.

  To pass exception information, use the keyword argument exc_info with
  a true value, e.g.

  logger.warning("Houston, we have a %s", "bit of a problem", exc_info=True)

  ## Parameters

  - `msg` (term())
  - `args` (term())
  - `kwargs` (term())

  ## Returns

  - `term()`
  """
  @spec warning(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def warning(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :warning, [msg] ++ List.wrap(args), opts)
  end

  @doc """
  As [`warning`][logging.Logger.warning], but subsequent calls with

  the same message are silently dropped.

  ## Parameters

  - `msg` (String.t())
  - `args` (term())
  - `scope` (term() keyword-only default: 'process')

  ## Returns

  - `nil`
  """
  @spec warning_once(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def warning_once(ref, msg, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :warning_once, [msg] ++ List.wrap(args), opts)
  end

  @spec manager(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def manager(ref) do
    SnakeBridge.Runtime.get_attr(ref, :manager)
  end

  @spec root(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def root(ref) do
    SnakeBridge.Runtime.get_attr(ref, :root)
  end
end
