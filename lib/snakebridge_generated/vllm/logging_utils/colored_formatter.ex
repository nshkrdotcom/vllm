# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.logging_utils
# Python class: ColoredFormatter

defmodule Vllm.LoggingUtils.ColoredFormatter do
  @moduledoc """
  Adds ANSI color codes to log levels for terminal output.

  This formatter adds colors by injecting them into the format string for
  static elements (timestamp, filename, line number) and modifying the
  levelname attribute for dynamic color selection.
  """
  def __snakebridge_python_name__, do: "vllm.logging_utils"
  def __snakebridge_python_class__, do: "ColoredFormatter"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize the formatter with specified format strings.

  Initialize the formatter either with the specified format string, or a
  default as described above. Allow for specialized date formatting with
  the optional datefmt argument. If datefmt is omitted, you get an
  ISO8601-like (or RFC 3339-like) format.

  Use a style parameter of '%', '{' or '$' to specify that you want to
  use one of %-formatting, :meth:`str.format` (``{}``) formatting or
  :class:`string.Template` formatting in your format string.

  .. versionchanged:: 3.2
     Added the ``style`` parameter.

  ## Parameters

  - `fmt` (term())
  - `datefmt` (term() default: None)
  - `style` (term() default: '%')
  """
  @spec new(term(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(fmt, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [fmt] ++ List.wrap(args), opts)
  end

  @doc """
  localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,

  tm_sec,tm_wday,tm_yday,tm_isdst)

  Convert seconds since the Epoch to a time tuple expressing local time.
  When 'seconds' is not passed in, convert the current time instead.

  ## Returns

  - `term()`
  """
  @spec converter(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec converter(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def converter(ref) do
    SnakeBridge.Runtime.call_method(ref, :converter, [], [])
  end

  def converter(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [], opts)
  end

  def converter(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1], [])
  end

  def converter(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1], opts)
  end

  def converter(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2], [])
  end

  def converter(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2], opts)
  end

  def converter(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3], [])
  end

  def converter(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3], opts)
  end

  def converter(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4], [])
  end

  def converter(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4], opts)
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :converter, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :converter,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :converter,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :converter,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def converter(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :converter,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Format the specified record as text.

  The record's attribute dictionary is used as the operand to a
  string formatting operation which yields the returned string.
  Before formatting the dictionary, a couple of preparatory steps
  are carried out. The message attribute of the record is computed
  using LogRecord.getMessage(). If the formatting string uses the
  time (as determined by a call to usesTime(), formatTime() is
  called to format the event time. If there is exception information,
  it is formatted using formatException() and appended to the message.

  ## Parameters

  - `record` (term())

  ## Returns

  - `term()`
  """
  @spec format(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format(ref, record, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :format, [record], opts)
  end

  @doc """
  Format and return the specified exception information as a string.

  This default implementation just uses
  traceback.print_exception()

  ## Parameters

  - `ei` (term())

  ## Returns

  - `term()`
  """
  @spec format_exception(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_exception(ref, ei, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "formatException", [ei], opts)
  end

  @doc """
  Python method `ColoredFormatter.formatMessage`.

  ## Parameters

  - `record` (term())

  ## Returns

  - `term()`
  """
  @spec format_message(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_message(ref, record, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "formatMessage", [record], opts)
  end

  @doc """
  This method is provided as an extension point for specialized

  formatting of stack information.

  The input data is a string as returned from a call to
  :func:`traceback.print_stack`, but with the last trailing newline
  removed.

  The base implementation just returns the value passed in.

  ## Parameters

  - `stack_info` (term())

  ## Returns

  - `term()`
  """
  @spec format_stack(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_stack(ref, stack_info, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "formatStack", [stack_info], opts)
  end

  @doc """
  Return the creation time of the specified LogRecord as formatted text.

  This method should be called from format() by a formatter which
  wants to make use of a formatted time. This method can be overridden
  in formatters to provide for any specific requirement, but the
  basic behaviour is as follows: if datefmt (a string) is specified,
  it is used with time.strftime() to format the creation time of the
  record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
  The resulting string is returned. This function uses a user-configurable
  function to convert the creation time to a tuple. By default,
  time.localtime() is used; to change this for a particular formatter
  instance, set the 'converter' attribute to a function with the same
  signature as time.localtime() or time.gmtime(). To change it for all
  formatters, for example if you want all logging times to be shown in GMT,
  set the 'converter' attribute in the Formatter class.

  ## Parameters

  - `record` (term())
  - `datefmt` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec format_time(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def format_time(ref, record, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, "formatTime", [record] ++ List.wrap(args), opts)
  end

  @doc """
  Check if the format uses the creation time of the record.

  ## Returns

  - `term()`
  """
  @spec uses_time(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def uses_time(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "usesTime", [], opts)
  end

  @spec colors(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def colors(ref) do
    SnakeBridge.Runtime.get_attr(ref, :COLORS)
  end

  @spec grey(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grey(ref) do
    SnakeBridge.Runtime.get_attr(ref, :GREY)
  end

  @spec reset(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def reset(ref) do
    SnakeBridge.Runtime.get_attr(ref, :RESET)
  end

  @spec default_msec_format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def default_msec_format(ref) do
    SnakeBridge.Runtime.get_attr(ref, :default_msec_format)
  end

  @spec default_time_format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def default_time_format(ref) do
    SnakeBridge.Runtime.get_attr(ref, :default_time_format)
  end
end
