# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: MultiModalConfig

defmodule Vllm.Config.MultiModalConfig do
  @moduledoc """
  Controls the behavior of multimodal models.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "MultiModalConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `MultiModalConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Python method `MultiModalConfig._validate_limit_per_prompt`.

  ## Parameters

  - `value` (%{optional(String.t()) => term()})

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec _validate_limit_per_prompt(
          SnakeBridge.Ref.t(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def _validate_limit_per_prompt(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_limit_per_prompt, [value], opts)
  end

  @doc """
  Python method `MultiModalConfig._validate_mm_encoder_attn_backend`.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec _validate_mm_encoder_attn_backend(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_mm_encoder_attn_backend(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_mm_encoder_attn_backend, [value], opts)
  end

  @doc """
  Python method `MultiModalConfig._validate_multimodal_config`.

  ## Returns

  - `term()`
  """
  @spec _validate_multimodal_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_multimodal_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_multimodal_config, [], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Get the configurable dummy data options for a modality.

  Returns None if no options are configured for this modality.

  ## Parameters

  - `modality` (String.t())

  ## Returns

  - `term()`
  """
  @spec get_dummy_options(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_dummy_options(ref, modality, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_dummy_options, [modality], opts)
  end

  @doc """
  Get the maximum number of input items allowed per prompt

  for the given modality (backward compatible).

  ## Parameters

  - `modality` (String.t())

  ## Returns

  - `integer()`
  """
  @spec get_limit_per_prompt(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_limit_per_prompt(ref, modality, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_limit_per_prompt, [modality], opts)
  end

  @doc """
  Python method `MultiModalConfig.is_multimodal_pruning_enabled`.

  ## Returns

  - `term()`
  """
  @spec is_multimodal_pruning_enabled(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_multimodal_pruning_enabled(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_multimodal_pruning_enabled, [], opts)
  end

  @doc """
  Get the keyword arguments to pass to the multi-modal processor

  according to the extra arguments passed during inference.

  ## Parameters

  - `inference_kwargs` (term())

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec merge_mm_processor_kwargs(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def merge_mm_processor_kwargs(ref, inference_kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :merge_mm_processor_kwargs, [inference_kwargs], opts)
  end

  @spec enable_mm_embeds(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_mm_embeds(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_mm_embeds)
  end

  @spec interleave_mm_strings(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def interleave_mm_strings(ref) do
    SnakeBridge.Runtime.get_attr(ref, :interleave_mm_strings)
  end

  @spec limit_per_prompt(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def limit_per_prompt(ref) do
    SnakeBridge.Runtime.get_attr(ref, :limit_per_prompt)
  end

  @spec media_io_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def media_io_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :media_io_kwargs)
  end

  @spec mm_encoder_attn_backend(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_encoder_attn_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_encoder_attn_backend)
  end

  @spec mm_encoder_tp_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_encoder_tp_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_encoder_tp_mode)
  end

  @spec mm_processor_cache_gb(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_cache_gb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_cache_gb)
  end

  @spec mm_processor_cache_type(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_cache_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_cache_type)
  end

  @spec mm_processor_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_kwargs)
  end

  @spec mm_shm_cache_max_object_size_mb(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_shm_cache_max_object_size_mb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_shm_cache_max_object_size_mb)
  end

  @spec skip_mm_profiling(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_mm_profiling(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_mm_profiling)
  end

  @spec video_pruning_rate(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def video_pruning_rate(ref) do
    SnakeBridge.Runtime.get_attr(ref, :video_pruning_rate)
  end
end
