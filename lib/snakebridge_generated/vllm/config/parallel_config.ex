# Generated by SnakeBridge v0.15.1 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: ParallelConfig

defmodule Vllm.Config.ParallelConfig do
  @moduledoc """
  Configuration for the distributed execution.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "ParallelConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `ParallelConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Skip validation if the value is `None` when initialisation is delayed.

  ## Parameters

  - `value` (term())
  - `handler` (term())

  ## Returns

  - `term()`
  """
  @spec _skip_none_validation(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _skip_none_validation(ref, value, handler, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_skip_none_validation, [value, handler], opts)
  end

  @doc """
  Python method `ParallelConfig._validate_parallel_config`.

  ## Returns

  - `term()`
  """
  @spec _validate_parallel_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_parallel_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_parallel_config, [], opts)
  end

  @doc """
  Python method `ParallelConfig._verify_args`.

  ## Returns

  - `term()`
  """
  @spec _verify_args(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _verify_args(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_args, [], opts)
  end

  @doc """
  Provide a hash that uniquely identifies all the configs

  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  This hash is also used for DP worker configuration validation
  to prevent hangs from mismatched collective communication patterns.

  ## Returns

  - `term()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  We might need to initialize process groups in multiple

  processes that is related to data parallelism,
  e.g. both in the worker and in the engine, which
  can live in different processes. To avoid port conflicts, we
  pop a new port from the prepared port list each time we need to
  initialize a new process group related to data parallelism.

  ## Returns

  - `integer()`
  """
  @spec get_next_dp_init_port(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_next_dp_init_port(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_next_dp_init_port, [], opts)
  end

  @doc """
  Python method `ParallelConfig.has_unfinished_dp`.

  ## Parameters

  - `dp_group` (term())
  - `has_unfinished` (boolean())

  ## Returns

  - `boolean()`
  """
  @spec has_unfinished_dp(SnakeBridge.Ref.t(), term(), boolean(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def has_unfinished_dp(ref, dp_group, has_unfinished, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :has_unfinished_dp, [dp_group, has_unfinished], opts)
  end

  @doc """
  Python method `ParallelConfig.stateless_init_dp_group`.

  ## Returns

  - `term()`
  """
  @spec stateless_init_dp_group(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def stateless_init_dp_group(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :stateless_init_dp_group, [], opts)
  end

  @doc """
  Python method `ParallelConfig.sync_kv_cache_memory_size`.

  ## Parameters

  - `dp_group` (term())
  - `kv_cache_memory` (integer())

  ## Returns

  - `integer()`
  """
  @spec sync_kv_cache_memory_size(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def sync_kv_cache_memory_size(ref, dp_group, kv_cache_memory, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :sync_kv_cache_memory_size,
      [dp_group, kv_cache_memory],
      opts
    )
  end

  @spec _api_process_count(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _api_process_count(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_api_process_count)
  end

  @spec _api_process_rank(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _api_process_rank(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_api_process_rank)
  end

  @spec _data_parallel_master_port_list(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _data_parallel_master_port_list(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_data_parallel_master_port_list)
  end

  @spec all2all_backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def all2all_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :all2all_backend)
  end

  @spec cp_kv_cache_interleave_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cp_kv_cache_interleave_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cp_kv_cache_interleave_size)
  end

  @spec data_parallel_backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_backend)
  end

  @spec data_parallel_external_lb(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_external_lb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_external_lb)
  end

  @spec data_parallel_hybrid_lb(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_hybrid_lb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_hybrid_lb)
  end

  @spec data_parallel_index(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_index(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_index)
  end

  @spec data_parallel_master_ip(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_master_ip(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_master_ip)
  end

  @spec data_parallel_master_port(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_master_port(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_master_port)
  end

  @spec data_parallel_rank(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_rank(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_rank)
  end

  @spec data_parallel_rank_local(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_rank_local(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_rank_local)
  end

  @spec data_parallel_rpc_port(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_rpc_port(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_rpc_port)
  end

  @spec data_parallel_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_size)
  end

  @spec data_parallel_size_local(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def data_parallel_size_local(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data_parallel_size_local)
  end

  @spec dbo_decode_token_threshold(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dbo_decode_token_threshold(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dbo_decode_token_threshold)
  end

  @spec dbo_prefill_token_threshold(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dbo_prefill_token_threshold(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dbo_prefill_token_threshold)
  end

  @spec dcp_kv_cache_interleave_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dcp_kv_cache_interleave_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dcp_kv_cache_interleave_size)
  end

  @spec decode_context_parallel_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def decode_context_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :decode_context_parallel_size)
  end

  @spec disable_custom_all_reduce(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_custom_all_reduce(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_custom_all_reduce)
  end

  @spec disable_nccl_for_dp_synchronization(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_nccl_for_dp_synchronization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_nccl_for_dp_synchronization)
  end

  @spec distributed_executor_backend(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def distributed_executor_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :distributed_executor_backend)
  end

  @spec enable_dbo(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_dbo(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_dbo)
  end

  @spec enable_eplb(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_eplb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_eplb)
  end

  @spec enable_expert_parallel(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_expert_parallel(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_expert_parallel)
  end

  @spec eplb_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def eplb_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :eplb_config)
  end

  @spec expert_placement_strategy(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def expert_placement_strategy(ref) do
    SnakeBridge.Runtime.get_attr(ref, :expert_placement_strategy)
  end

  @spec is_moe_model(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_moe_model(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_moe_model)
  end

  @spec local_world_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def local_world_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :local_world_size)
  end

  @spec master_addr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def master_addr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :master_addr)
  end

  @spec master_port(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def master_port(ref) do
    SnakeBridge.Runtime.get_attr(ref, :master_port)
  end

  @spec max_parallel_loading_workers(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_parallel_loading_workers(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_parallel_loading_workers)
  end

  @spec nnodes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nnodes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nnodes)
  end

  @spec nnodes_within_dp(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nnodes_within_dp(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nnodes_within_dp)
  end

  @spec node_rank(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def node_rank(ref) do
    SnakeBridge.Runtime.get_attr(ref, :node_rank)
  end

  @spec node_rank_within_dp(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def node_rank_within_dp(ref) do
    SnakeBridge.Runtime.get_attr(ref, :node_rank_within_dp)
  end

  @spec num_ubatches(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_ubatches(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_ubatches)
  end

  @spec pipeline_parallel_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def pipeline_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :pipeline_parallel_size)
  end

  @spec placement_group(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def placement_group(ref) do
    SnakeBridge.Runtime.get_attr(ref, :placement_group)
  end

  @spec prefill_context_parallel_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def prefill_context_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :prefill_context_parallel_size)
  end

  @spec rank(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def rank(ref) do
    SnakeBridge.Runtime.get_attr(ref, :rank)
  end

  @spec ray_runtime_env(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ray_runtime_env(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ray_runtime_env)
  end

  @spec ray_workers_use_nsight(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def ray_workers_use_nsight(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ray_workers_use_nsight)
  end

  @spec sd_worker_cls(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def sd_worker_cls(ref) do
    SnakeBridge.Runtime.get_attr(ref, :sd_worker_cls)
  end

  @spec tensor_parallel_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tensor_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tensor_parallel_size)
  end

  @spec ubatch_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ubatch_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ubatch_size)
  end

  @spec use_ray(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_ray(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_ray)
  end

  @spec use_sequence_parallel_moe(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_sequence_parallel_moe(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_sequence_parallel_moe)
  end

  @spec use_ubatching(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_ubatching(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_ubatching)
  end

  @spec worker_cls(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def worker_cls(ref) do
    SnakeBridge.Runtime.get_attr(ref, :worker_cls)
  end

  @spec worker_extension_cls(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def worker_extension_cls(ref) do
    SnakeBridge.Runtime.get_attr(ref, :worker_extension_cls)
  end

  @spec world_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def world_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :world_size)
  end

  @spec world_size_across_dp(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def world_size_across_dp(ref) do
    SnakeBridge.Runtime.get_attr(ref, :world_size_across_dp)
  end
end
