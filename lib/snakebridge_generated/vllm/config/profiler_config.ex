# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: ProfilerConfig

defmodule Vllm.Config.ProfilerConfig do
  @moduledoc """
  Dataclass which contains profiler config for the engine.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "ProfilerConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `ProfilerConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Get field from env var if set, with deprecation warning.

  ## Parameters

  - `field_name` (String.t())
  - `env_var_name` (String.t())

  ## Returns

  - `nil`
  """
  @spec _get_from_env_if_set(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _get_from_env_if_set(ref, field_name, env_var_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_from_env_if_set, [field_name, env_var_name], opts)
  end

  @doc """
  Set field from env var if set, with deprecation warning.

  ## Parameters

  - `field_name` (String.t())
  - `env_var_name` (String.t())
  - `to_bool` (boolean() default: True)
  - `to_int` (boolean() default: False)

  ## Returns

  - `nil`
  """
  @spec _set_from_env_if_set(SnakeBridge.Ref.t(), String.t(), String.t(), list(term()), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _set_from_env_if_set(ref, field_name, env_var_name, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :_set_from_env_if_set,
      [field_name, env_var_name] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `ProfilerConfig._validate_profiler_config`.

  ## Returns

  - `term()`
  """
  @spec _validate_profiler_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_profiler_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_profiler_config, [], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @spec delay_iterations(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def delay_iterations(ref) do
    SnakeBridge.Runtime.get_attr(ref, :delay_iterations)
  end

  @spec ignore_frontend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ignore_frontend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ignore_frontend)
  end

  @spec max_iterations(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_iterations(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_iterations)
  end

  @spec profiler(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def profiler(ref) do
    SnakeBridge.Runtime.get_attr(ref, :profiler)
  end

  @spec torch_profiler_dir(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_dir(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_dir)
  end

  @spec torch_profiler_dump_cuda_time_total(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_dump_cuda_time_total(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_dump_cuda_time_total)
  end

  @spec torch_profiler_record_shapes(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_record_shapes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_record_shapes)
  end

  @spec torch_profiler_use_gzip(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_use_gzip(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_use_gzip)
  end

  @spec torch_profiler_with_flops(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_with_flops(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_with_flops)
  end

  @spec torch_profiler_with_memory(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_with_memory(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_with_memory)
  end

  @spec torch_profiler_with_stack(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def torch_profiler_with_stack(ref) do
    SnakeBridge.Runtime.get_attr(ref, :torch_profiler_with_stack)
  end
end
