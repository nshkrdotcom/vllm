# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: CompilationConfig

defmodule Vllm.Config.CompilationConfig do
  @moduledoc """
  Configuration for compilation.

  You must pass CompilationConfig to VLLMConfig constructor.
  VLLMConfig's post_init does further initialization. If used outside of the
  VLLMConfig, some fields will be left in an improper state.

  It has three parts:

  - Top-level Compilation control:
      - [`mode`][vllm.config.CompilationConfig.mode]
      - [`debug_dump_path`][vllm.config.CompilationConfig.debug_dump_path]
      - [`cache_dir`][vllm.config.CompilationConfig.cache_dir]
      - [`backend`][vllm.config.CompilationConfig.backend]
      - [`custom_ops`][vllm.config.CompilationConfig.custom_ops]
      - [`splitting_ops`][vllm.config.CompilationConfig.splitting_ops]
      - [`compile_mm_encoder`][vllm.config.CompilationConfig.compile_mm_encoder]
  - CudaGraph capture:
      - [`cudagraph_mode`][vllm.config.CompilationConfig.cudagraph_mode]
      - [`cudagraph_capture_sizes`]
      [vllm.config.CompilationConfig.cudagraph_capture_sizes]
      - [`max_cudagraph_capture_size`]
      [vllm.config.CompilationConfig.max_cudagraph_capture_size]
      - [`cudagraph_num_of_warmups`]
      [vllm.config.CompilationConfig.cudagraph_num_of_warmups]
      - [`cudagraph_copy_inputs`]
      [vllm.config.CompilationConfig.cudagraph_copy_inputs]
  - Inductor compilation:
      - [`compile_sizes`][vllm.config.CompilationConfig.compile_sizes]
      - [`compile_ranges_split_points`]
          [vllm.config.CompilationConfig.compile_ranges_split_points]
      - [`inductor_compile_config`]
      [vllm.config.CompilationConfig.inductor_compile_config]
      - [`inductor_passes`][vllm.config.CompilationConfig.inductor_passes]
      - custom inductor passes

  Why we have different sizes for cudagraph and inductor:
  - cudagraph: a cudagraph captured for a specific size can only be used
      for the same size. We need to capture all the sizes we want to use.
  - inductor: a graph compiled by inductor for a general shape can be used
      for different sizes. Inductor can also compile for specific sizes,
      where it can have more information to optimize the graph with fully
      static shapes. However, we find the general shape compilation is
      sufficient for most cases. It might be beneficial to compile for
      certain small batchsizes, where inductor is good at optimizing.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "CompilationConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `CompilationConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Skip validation if the value is `None` when initialisation is delayed.

  ## Parameters

  - `value` (term())
  - `handler` (term())

  ## Returns

  - `term()`
  """
  @spec _skip_none_validation(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _skip_none_validation(ref, value, handler, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_skip_none_validation, [value, handler], opts)
  end

  @doc """
  Python method `CompilationConfig.adjust_cudagraph_sizes_for_spec_decode`.

  ## Parameters

  - `uniform_decode_query_len` (integer())
  - `tensor_parallel_size` (integer())

  ## Returns

  - `term()`
  """
  @spec adjust_cudagraph_sizes_for_spec_decode(
          SnakeBridge.Ref.t(),
          integer(),
          integer(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def adjust_cudagraph_sizes_for_spec_decode(
        ref,
        uniform_decode_query_len,
        tensor_parallel_size,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :adjust_cudagraph_sizes_for_spec_decode,
      [uniform_decode_query_len, tensor_parallel_size],
      opts
    )
  end

  @doc """
  Python method `CompilationConfig.compute_bs_to_padded_graph_size`.

  ## Returns

  - `term()`
  """
  @spec compute_bs_to_padded_graph_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def compute_bs_to_padded_graph_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_bs_to_padded_graph_size, [], opts)
  end

  @doc """
  Provide a hash that uniquely identifies all the configs

  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  This method logs the enabled/disabled custom ops and checks that the

  passed custom_ops field only contains relevant ops.
  It is called at the end of set_current_vllm_config,
  after the custom ops have been instantiated.

  ## Returns

  - `term()`
  """
  @spec custom_op_log_check(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def custom_op_log_check(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :custom_op_log_check, [], opts)
  end

  @doc """
  Get the compile ranges for the compilation config.

  ## Returns

  - `list(term())`
  """
  @spec get_compile_ranges(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, list(term())} | {:error, Snakepit.Error.t()}
  def get_compile_ranges(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_compile_ranges, [], opts)
  end

  @doc """
  Initialize the backend for the compilation config from a vllm config.



  ## Parameters

  - `vllm_config` - The vllm config to initialize the backend from.

  ## Returns

  - `term()`
  """
  @spec init_backend(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def init_backend(ref, vllm_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :init_backend, [vllm_config], opts)
  end

  @doc """
  Python method `CompilationConfig.is_attention_compiled_piecewise`.

  ## Returns

  - `boolean()`
  """
  @spec is_attention_compiled_piecewise(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_attention_compiled_piecewise(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_attention_compiled_piecewise, [], opts)
  end

  @doc """
  Python method `CompilationConfig.is_custom_op_enabled`.

  ## Parameters

  - `op` (String.t())

  ## Returns

  - `boolean()`
  """
  @spec is_custom_op_enabled(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_custom_op_enabled(ref, op, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_custom_op_enabled, [op], opts)
  end

  @doc """
  To complete the initialization after cudagraph related

  configs are set. This includes:
  - initialize compile_sizes
  - pre-compute the mapping bs_to_padded_graph_size

  ## Returns

  - `nil`
  """
  @spec post_init_cudagraph_sizes(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def post_init_cudagraph_sizes(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :post_init_cudagraph_sizes, [], opts)
  end

  @doc """
  Python method `CompilationConfig.set_splitting_ops_for_attn_fusion`.

  ## Returns

  - `term()`
  """
  @spec set_splitting_ops_for_attn_fusion(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def set_splitting_ops_for_attn_fusion(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :set_splitting_ops_for_attn_fusion, [], opts)
  end

  @doc """
  Python method `CompilationConfig.set_splitting_ops_for_v1`.

  ## Parameters

  - `all2all_backend` (String.t())
  - `data_parallel_size` (integer() default: 1)

  ## Returns

  - `term()`
  """
  @spec set_splitting_ops_for_v1(SnakeBridge.Ref.t(), String.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def set_splitting_ops_for_v1(ref, all2all_backend, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :set_splitting_ops_for_v1,
      [all2all_backend] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `CompilationConfig.splitting_ops_contain_attention`.

  ## Returns

  - `boolean()`
  """
  @spec splitting_ops_contain_attention(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def splitting_ops_contain_attention(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :splitting_ops_contain_attention, [], opts)
  end

  @doc """
  Python method `CompilationConfig.validate_compile_cache_save_format`.

  ## Parameters

  - `value` (String.t())

  ## Returns

  - `String.t()`
  """
  @spec validate_compile_cache_save_format(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def validate_compile_cache_save_format(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_compile_cache_save_format, [value], opts)
  end

  @doc """
  Enable parsing of the `cudagraph_mode` enum type from string.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate_cudagraph_mode_before(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_cudagraph_mode_before(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_cudagraph_mode_before, [value], opts)
  end

  @doc """
  Enable parsing the `mode` field from string mode names.

  Accepts both integers (0-3) and string names, like NONE, STOCK_TORCH_COMPILE,
  DYNAMO_TRACE_ONCE, VLLM_COMPILE.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate_mode_before(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_mode_before(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_mode_before, [value], opts)
  end

  @doc """
  Enable parsing of the `pass_config` field from a dictionary.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate_pass_config_before(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_pass_config_before(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_pass_config_before, [value], opts)
  end

  @spec _attention_ops(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _attention_ops(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_attention_ops)
  end

  @spec backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :backend)
  end

  @spec bs_to_padded_graph_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def bs_to_padded_graph_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :bs_to_padded_graph_size)
  end

  @spec cache_dir(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cache_dir(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cache_dir)
  end

  @spec compilation_time(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def compilation_time(ref) do
    SnakeBridge.Runtime.get_attr(ref, :compilation_time)
  end

  @spec compile_mm_encoder(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def compile_mm_encoder(ref) do
    SnakeBridge.Runtime.get_attr(ref, :compile_mm_encoder)
  end

  @spec compile_ranges_split_points(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def compile_ranges_split_points(ref) do
    SnakeBridge.Runtime.get_attr(ref, :compile_ranges_split_points)
  end

  @spec compile_sizes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def compile_sizes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :compile_sizes)
  end

  @spec cudagraph_capture_sizes(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cudagraph_capture_sizes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cudagraph_capture_sizes)
  end

  @spec cudagraph_copy_inputs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cudagraph_copy_inputs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cudagraph_copy_inputs)
  end

  @spec cudagraph_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cudagraph_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cudagraph_mode)
  end

  @spec cudagraph_num_of_warmups(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cudagraph_num_of_warmups(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cudagraph_num_of_warmups)
  end

  @spec cudagraph_specialize_lora(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cudagraph_specialize_lora(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cudagraph_specialize_lora)
  end

  @spec debug_dump_path(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def debug_dump_path(ref) do
    SnakeBridge.Runtime.get_attr(ref, :debug_dump_path)
  end

  @spec level(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def level(ref) do
    SnakeBridge.Runtime.get_attr(ref, :level)
  end

  @spec local_cache_dir(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def local_cache_dir(ref) do
    SnakeBridge.Runtime.get_attr(ref, :local_cache_dir)
  end

  @spec max_cudagraph_capture_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_cudagraph_capture_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_cudagraph_capture_size)
  end

  @spec mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mode)
  end

  @spec splitting_ops(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def splitting_ops(ref) do
    SnakeBridge.Runtime.get_attr(ref, :splitting_ops)
  end

  @spec use_inductor_graph_partition(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_inductor_graph_partition(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_inductor_graph_partition)
  end
end
