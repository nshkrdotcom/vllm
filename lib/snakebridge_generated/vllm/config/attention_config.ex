# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: AttentionConfig

defmodule Vllm.Config.AttentionConfig do
  @moduledoc """
  Configuration for attention mechanisms in vLLM.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "AttentionConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `AttentionConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Set field from env var if set, with deprecation warning.

  ## Parameters

  - `field_name` (String.t())
  - `env_var_name` (String.t())

  ## Returns

  - `nil`
  """
  @spec _set_from_env_if_set(SnakeBridge.Ref.t(), String.t(), String.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _set_from_env_if_set(ref, field_name, env_var_name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_set_from_env_if_set, [field_name, env_var_name], opts)
  end

  @doc """
  Provide a hash that uniquely identifies all the configs

  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Enable parsing of the `backend` enum type from string.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate_backend_before(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_backend_before(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_backend_before, [value], opts)
  end

  @spec backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :backend)
  end

  @spec disable_flashinfer_prefill(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_flashinfer_prefill(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_flashinfer_prefill)
  end

  @spec disable_flashinfer_q_quantization(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_flashinfer_q_quantization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_flashinfer_q_quantization)
  end

  @spec flash_attn_max_num_splits_for_cuda_graph(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def flash_attn_max_num_splits_for_cuda_graph(ref) do
    SnakeBridge.Runtime.get_attr(ref, :flash_attn_max_num_splits_for_cuda_graph)
  end

  @spec flash_attn_version(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def flash_attn_version(ref) do
    SnakeBridge.Runtime.get_attr(ref, :flash_attn_version)
  end

  @spec use_cudnn_prefill(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_cudnn_prefill(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_cudnn_prefill)
  end

  @spec use_prefill_decode_attention(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_prefill_decode_attention(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_prefill_decode_attention)
  end

  @spec use_trtllm_attention(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_trtllm_attention(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_trtllm_attention)
  end

  @spec use_trtllm_ragged_deepseek_prefill(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_trtllm_ragged_deepseek_prefill(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_trtllm_ragged_deepseek_prefill)
  end
end
