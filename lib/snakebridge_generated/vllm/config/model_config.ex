# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: ModelConfig

defmodule Vllm.Config.ModelConfig do
  @moduledoc """
  Configuration for the model.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "ModelConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `ModelConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Python method `ModelConfig._verify_cuda_graph`.

  ## Returns

  - `nil`
  """
  @spec _verify_cuda_graph(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_cuda_graph(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_cuda_graph, [], opts)
  end

  @doc """
  Get the sliding window size from the HF text config if present.

  ## Returns

  - `term()`
  """
  @spec get_sliding_window(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_sliding_window(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_sliding_window, [], opts)
  end

  @doc """
  Called after __post_init__

  ## Returns

  - `term()`
  """
  @spec validate_model_config_after(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_model_config_after(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_model_config_after, [], opts)
  end

  @doc """
  Returns the number of KV heads per GPU.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `integer()`
  """
  @spec get_num_kv_heads(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_num_kv_heads(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_num_kv_heads, [parallel_config], opts)
  end

  @doc """
  Python method `ModelConfig.get_num_experts`.

  ## Returns

  - `integer()`
  """
  @spec get_num_experts(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_num_experts(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_num_experts, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_vocab_size`.

  ## Returns

  - `integer()`
  """
  @spec get_vocab_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_vocab_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_vocab_size, [], opts)
  end

  @doc """
  Python method `ModelConfig._get_encoder_config`.

  ## Returns

  - `term()`
  """
  @spec _get_encoder_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_encoder_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_encoder_config, [], opts)
  end

  @doc """
  Recursively updates a config or dict with nested updates.

  ## Parameters

  - `target` (term())
  - `updates` (%{optional(String.t()) => term()})

  ## Returns

  - `nil`
  """
  @spec _update_nested(SnakeBridge.Ref.t(), term(), %{optional(String.t()) => term()}, keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _update_nested(ref, target, updates, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_update_nested, [target, updates], opts)
  end

  @doc """
  Python method `ModelConfig.get_model_arch_config`.

  ## Returns

  - `term()`
  """
  @spec get_model_arch_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_model_arch_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_model_arch_config, [], opts)
  end

  @doc """
  Apply dict overrides, handling both nested configs and dict values.

  ## Parameters

  - `config` (term())
  - `overrides` (%{optional(String.t()) => term()})

  ## Returns

  - `nil`
  """
  @spec _apply_dict_overrides(
          SnakeBridge.Ref.t(),
          term(),
          %{optional(String.t()) => term()},
          keyword()
        ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def _apply_dict_overrides(ref, config, overrides, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_apply_dict_overrides, [config, overrides], opts)
  end

  @doc """
  Pull model/tokenizer from Object Storage to temporary

  directory when needed.

  ## Parameters

  - `model` - Model name or path
  - `tokenizer` - Tokenizer name or path

  ## Returns

  - `nil`
  """
  @spec maybe_pull_model_tokenizer_for_runai(
          SnakeBridge.Ref.t(),
          String.t(),
          String.t(),
          keyword()
        ) :: {:ok, nil} | {:error, Snakepit.Error.t()}
  def maybe_pull_model_tokenizer_for_runai(ref, model, tokenizer, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :maybe_pull_model_tokenizer_for_runai,
      [model, tokenizer],
      opts
    )
  end

  @doc """
  This method returns a dictionary containing the non-default sampling

  parameters with `override_generation_config` applied.

  The default sampling parameters are:

  - vLLM's neutral defaults if `self.generation_config="vllm"`
  - the model's defaults if `self.generation_config="auto"`
  - as defined in `generation_config.json` if
      `self.generation_config="path/to/generation_config/dir"`

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec get_diff_sampling_param(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def get_diff_sampling_param(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_diff_sampling_param, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_total_num_hidden_layers`.

  ## Returns

  - `integer()`
  """
  @spec get_total_num_hidden_layers(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_total_num_hidden_layers(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_total_num_hidden_layers, [], opts)
  end

  @doc """
  Python method `ModelConfig._get_runner_type`.

  ## Parameters

  - `architectures` (list(String.t()))
  - `runner` (term())

  ## Returns

  - `term()`
  """
  @spec _get_runner_type(SnakeBridge.Ref.t(), list(String.t()), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_runner_type(ref, architectures, runner, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_runner_type, [architectures, runner], opts)
  end

  @doc """
  Skip validation if the value is `None` when initialisation is delayed.

  ## Parameters

  - `value` (term())
  - `handler` (term())

  ## Returns

  - `term()`
  """
  @spec _skip_none_validation(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _skip_none_validation(ref, value, handler, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_skip_none_validation, [value, handler], opts)
  end

  @doc """
  Check if the model is using the Transformers modeling backend class.

  ## Returns

  - `boolean()`
  """
  @spec using_transformers_backend(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def using_transformers_backend(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :using_transformers_backend, [], opts)
  end

  @doc """
  Python method `ModelConfig._try_verify_and_update_model_config`.

  ## Returns

  - `term()`
  """
  @spec _try_verify_and_update_model_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _try_verify_and_update_model_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_try_verify_and_update_model_config, [], opts)
  end

  @doc """
  Returns the mamba chunk size if it exists

  ## Returns

  - `term()`
  """
  @spec get_mamba_chunk_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_mamba_chunk_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_mamba_chunk_size, [], opts)
  end

  @doc """
  Get the multimodal configuration of the model.



  ## Raises

  - `ArgumentError` - If the model is not multimodal.

  ## Returns

  - `term()`
  """
  @spec get_multimodal_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_multimodal_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_multimodal_config, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_hidden_size`.

  ## Returns

  - `integer()`
  """
  @spec get_hidden_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_hidden_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_hidden_size, [], opts)
  end

  @doc """
  Python method `ModelConfig._get_convert_type`.

  ## Parameters

  - `architectures` (list(String.t()))
  - `runner_type` (term())
  - `convert` (term())

  ## Returns

  - `term()`
  """
  @spec _get_convert_type(SnakeBridge.Ref.t(), list(String.t()), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_convert_type(ref, architectures, runner_type, convert, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_get_convert_type,
      [architectures, runner_type, convert],
      opts
    )
  end

  @doc """
  Python method `ModelConfig.get_num_attention_heads`.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `integer()`
  """
  @spec get_num_attention_heads(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_num_attention_heads(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_num_attention_heads, [parallel_config], opts)
  end

  @doc """
  The current version of bitsandbytes (0.46.1) with 8-bit models does not

  yet support CUDA graph.
  # TODO Remove this when bitsandbytes supports.

  ## Returns

  - `nil`
  """
  @spec _verify_bnb_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_bnb_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_bnb_config, [], opts)
  end

  @doc """
  Python method `ModelConfig._get_default_convert_type`.

  ## Parameters

  - `architectures` (list(String.t()))
  - `runner_type` (term())

  ## Returns

  - `term()`
  """
  @spec _get_default_convert_type(SnakeBridge.Ref.t(), list(String.t()), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_default_convert_type(ref, architectures, runner_type, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_get_default_convert_type,
      [architectures, runner_type],
      opts
    )
  end

  @doc """
  Python method `ModelConfig.verify_dual_chunk_attention_config`.

  ## Parameters

  - `load_config` (term())

  ## Returns

  - `nil`
  """
  @spec verify_dual_chunk_attention_config(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify_dual_chunk_attention_config(ref, load_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :verify_dual_chunk_attention_config, [load_config], opts)
  end

  @doc """
  Python method `ModelConfig.get_and_verify_max_len`.

  ## Parameters

  - `max_model_len` (integer())

  ## Returns

  - `term()`
  """
  @spec get_and_verify_max_len(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_and_verify_max_len(ref, max_model_len, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_and_verify_max_len, [max_model_len], opts)
  end

  @doc """
  Python method `ModelConfig.verify_with_parallel_config`.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `nil`
  """
  @spec verify_with_parallel_config(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify_with_parallel_config(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :verify_with_parallel_config, [parallel_config], opts)
  end

  @doc """
  Python method `ModelConfig._verify_quantization`.

  ## Returns

  - `nil`
  """
  @spec _verify_quantization(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_quantization(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_quantization, [], opts)
  end

  @doc """
  Python method `ModelConfig.validate_quantization_before`.

  ## Parameters

  - `value` (term())

  ## Returns

  - `term()`
  """
  @spec validate_quantization_before(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def validate_quantization_before(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :validate_quantization_before, [value], opts)
  end

  @doc """
  Python method `ModelConfig._get_default_runner_type`.

  ## Parameters

  - `architectures` (list(String.t()))

  ## Returns

  - `term()`
  """
  @spec _get_default_runner_type(SnakeBridge.Ref.t(), list(String.t()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _get_default_runner_type(ref, architectures, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_default_runner_type, [architectures], opts)
  end

  @doc """
  Python method `ModelConfig.get_head_size`.

  ## Returns

  - `integer()`
  """
  @spec get_head_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_head_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_head_size, [], opts)
  end

  @doc """
  Python method `ModelConfig._verify_with_expert_parallelism`.

  ## Returns

  - `nil`
  """
  @spec _verify_with_expert_parallelism(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def _verify_with_expert_parallelism(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_with_expert_parallelism, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_num_layers`.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `integer()`
  """
  @spec get_num_layers(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_num_layers(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_num_layers, [parallel_config], opts)
  end

  @doc """
  Returns the total number of KV heads.

  ## Returns

  - `integer()`
  """
  @spec get_total_num_kv_heads(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_total_num_kv_heads(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_total_num_kv_heads, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_layers_start_end_indices`.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `{integer(), integer()}`
  """
  @spec get_layers_start_end_indices(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, {integer(), integer()}} | {:error, Snakepit.Error.t()}
  def get_layers_start_end_indices(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_layers_start_end_indices, [parallel_config], opts)
  end

  @doc """
  This method attempts to retrieve the non-default values of the

  generation config for this model.

  The generation config can contain information about special tokens, as
  well as sampling parameters. Which is why this method exists separately
  to `get_diff_sampling_param`.

  ## Returns

  - `%{optional(String.t()) => term()}`
  """
  @spec try_get_generation_config(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(String.t()) => term()}} | {:error, Snakepit.Error.t()}
  def try_get_generation_config(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :try_get_generation_config, [], opts)
  end

  @doc """
  Python method `ModelConfig._lowercase_tokenizer_mode`.

  ## Parameters

  - `tokenizer_mode` (String.t())

  ## Returns

  - `String.t()`
  """
  @spec _lowercase_tokenizer_mode(SnakeBridge.Ref.t(), String.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _lowercase_tokenizer_mode(ref, tokenizer_mode, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_lowercase_tokenizer_mode, [tokenizer_mode], opts)
  end

  @doc """
  Determine which Transformers modeling backend class will be used if

  `model_impl` is set to `transformers` or `auto`.

  ## Returns

  - `String.t()`
  """
  @spec _get_transformers_backend_cls(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def _get_transformers_backend_cls(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_get_transformers_backend_cls, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_inputs_embeds_size`.

  ## Returns

  - `integer()`
  """
  @spec get_inputs_embeds_size(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_inputs_embeds_size(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_inputs_embeds_size, [], opts)
  end

  @doc """
  Python method `ModelConfig.get_num_layers_by_block_type`.

  ## Parameters

  - `parallel_config` (term())
  - `block_type` (term() default: 'attention')

  ## Returns

  - `integer()`
  """
  @spec get_num_layers_by_block_type(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def get_num_layers_by_block_type(ref, parallel_config, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_method(
      ref,
      :get_num_layers_by_block_type,
      [parallel_config] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @spec allow_deprecated_quantization(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def allow_deprecated_quantization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :allow_deprecated_quantization)
  end

  @spec allowed_local_media_path(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def allowed_local_media_path(ref) do
    SnakeBridge.Runtime.get_attr(ref, :allowed_local_media_path)
  end

  @spec allowed_media_domains(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def allowed_media_domains(ref) do
    SnakeBridge.Runtime.get_attr(ref, :allowed_media_domains)
  end

  @spec architecture(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def architecture(ref) do
    SnakeBridge.Runtime.get_attr(ref, :architecture)
  end

  @spec architectures(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def architectures(ref) do
    SnakeBridge.Runtime.get_attr(ref, :architectures)
  end

  @spec attn_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def attn_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :attn_type)
  end

  @spec code_revision(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def code_revision(ref) do
    SnakeBridge.Runtime.get_attr(ref, :code_revision)
  end

  @spec config_format(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def config_format(ref) do
    SnakeBridge.Runtime.get_attr(ref, :config_format)
  end

  @spec convert(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def convert(ref) do
    SnakeBridge.Runtime.get_attr(ref, :convert)
  end

  @spec disable_cascade_attn(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_cascade_attn(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_cascade_attn)
  end

  @spec disable_sliding_window(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_sliding_window(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_sliding_window)
  end

  @spec dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dtype)
  end

  @spec embedding_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def embedding_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :embedding_size)
  end

  @spec enable_mm_embeds(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_mm_embeds(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_mm_embeds)
  end

  @spec enable_prompt_embeds(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_prompt_embeds(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_prompt_embeds)
  end

  @spec enable_return_routed_experts(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_return_routed_experts(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_return_routed_experts)
  end

  @spec enable_sleep_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_sleep_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_sleep_mode)
  end

  @spec enforce_eager(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enforce_eager(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enforce_eager)
  end

  @spec generation_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def generation_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :generation_config)
  end

  @spec has_inner_state(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def has_inner_state(ref) do
    SnakeBridge.Runtime.get_attr(ref, :has_inner_state)
  end

  @spec has_noops(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def has_noops(ref) do
    SnakeBridge.Runtime.get_attr(ref, :has_noops)
  end

  @spec head_dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def head_dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :head_dtype)
  end

  @spec hf_config_path(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def hf_config_path(ref) do
    SnakeBridge.Runtime.get_attr(ref, :hf_config_path)
  end

  @spec hf_token(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def hf_token(ref) do
    SnakeBridge.Runtime.get_attr(ref, :hf_token)
  end

  @spec interleave_mm_strings(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def interleave_mm_strings(ref) do
    SnakeBridge.Runtime.get_attr(ref, :interleave_mm_strings)
  end

  @spec io_processor_plugin(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def io_processor_plugin(ref) do
    SnakeBridge.Runtime.get_attr(ref, :io_processor_plugin)
  end

  @spec is_attention_free(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_attention_free(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_attention_free)
  end

  @spec is_chunked_prefill_supported(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_chunked_prefill_supported(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_chunked_prefill_supported)
  end

  @spec is_cross_encoder(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_cross_encoder(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_cross_encoder)
  end

  @spec is_deepseek_mla(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_deepseek_mla(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_deepseek_mla)
  end

  @spec is_encoder_decoder(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_encoder_decoder(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_encoder_decoder)
  end

  @spec is_hybrid(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_hybrid(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_hybrid)
  end

  @spec is_matryoshka(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_matryoshka(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_matryoshka)
  end

  @spec is_mm_prefix_lm(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mm_prefix_lm(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_mm_prefix_lm)
  end

  @spec is_moe(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_moe(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_moe)
  end

  @spec is_multimodal_model(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_multimodal_model(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_multimodal_model)
  end

  @spec is_multimodal_raw_input_only_model(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_multimodal_raw_input_only_model(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_multimodal_raw_input_only_model)
  end

  @spec is_pp_supported(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_pp_supported(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_pp_supported)
  end

  @spec is_prefix_caching_supported(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_prefix_caching_supported(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_prefix_caching_supported)
  end

  @spec is_quantized(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_quantized(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_quantized)
  end

  @spec limit_mm_per_prompt(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def limit_mm_per_prompt(ref) do
    SnakeBridge.Runtime.get_attr(ref, :limit_mm_per_prompt)
  end

  @spec logits_processor_pattern(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def logits_processor_pattern(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logits_processor_pattern)
  end

  @spec logits_processors(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logits_processors(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logits_processors)
  end

  @spec logprobs_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logprobs_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logprobs_mode)
  end

  @spec matryoshka_dimensions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def matryoshka_dimensions(ref) do
    SnakeBridge.Runtime.get_attr(ref, :matryoshka_dimensions)
  end

  @spec max_logprobs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_logprobs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_logprobs)
  end

  @spec max_model_len(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_model_len(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_model_len)
  end

  @spec media_io_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def media_io_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :media_io_kwargs)
  end

  @spec mm_encoder_attn_backend(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_encoder_attn_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_encoder_attn_backend)
  end

  @spec mm_encoder_tp_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_encoder_tp_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_encoder_tp_mode)
  end

  @spec mm_processor_cache_gb(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_cache_gb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_cache_gb)
  end

  @spec mm_processor_cache_type(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_cache_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_cache_type)
  end

  @spec mm_processor_kwargs(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_processor_kwargs(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_processor_kwargs)
  end

  @spec mm_shm_cache_max_object_size_mb(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mm_shm_cache_max_object_size_mb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mm_shm_cache_max_object_size_mb)
  end

  @spec model(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model)
  end

  @spec model_impl(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_impl(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_impl)
  end

  @spec model_weights(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model_weights(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model_weights)
  end

  @spec multimodal_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def multimodal_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :multimodal_config)
  end

  @spec override_attention_dtype(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def override_attention_dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :override_attention_dtype)
  end

  @spec pooler_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def pooler_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :pooler_config)
  end

  @spec quantization(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def quantization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :quantization)
  end

  @spec registry(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def registry(ref) do
    SnakeBridge.Runtime.get_attr(ref, :registry)
  end

  @spec requires_raw_input_tokens(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def requires_raw_input_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :requires_raw_input_tokens)
  end

  @spec revision(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def revision(ref) do
    SnakeBridge.Runtime.get_attr(ref, :revision)
  end

  @spec runner(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def runner(ref) do
    SnakeBridge.Runtime.get_attr(ref, :runner)
  end

  @spec seed(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def seed(ref) do
    SnakeBridge.Runtime.get_attr(ref, :seed)
  end

  @spec served_model_name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def served_model_name(ref) do
    SnakeBridge.Runtime.get_attr(ref, :served_model_name)
  end

  @spec skip_mm_profiling(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_mm_profiling(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_mm_profiling)
  end

  @spec skip_tokenizer_init(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def skip_tokenizer_init(ref) do
    SnakeBridge.Runtime.get_attr(ref, :skip_tokenizer_init)
  end

  @spec spec_target_max_model_len(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def spec_target_max_model_len(ref) do
    SnakeBridge.Runtime.get_attr(ref, :spec_target_max_model_len)
  end

  @spec supports_mamba_prefix_caching(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def supports_mamba_prefix_caching(ref) do
    SnakeBridge.Runtime.get_attr(ref, :supports_mamba_prefix_caching)
  end

  @spec tokenizer(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tokenizer(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tokenizer)
  end

  @spec tokenizer_mode(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tokenizer_mode(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tokenizer_mode)
  end

  @spec tokenizer_revision(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tokenizer_revision(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tokenizer_revision)
  end

  @spec trust_remote_code(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def trust_remote_code(ref) do
    SnakeBridge.Runtime.get_attr(ref, :trust_remote_code)
  end

  @spec use_mla(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_mla(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_mla)
  end

  @spec use_sep_token(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_sep_token(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_sep_token)
  end

  @spec uses_alibi(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def uses_alibi(ref) do
    SnakeBridge.Runtime.get_attr(ref, :uses_alibi)
  end

  @spec uses_mrope(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def uses_mrope(ref) do
    SnakeBridge.Runtime.get_attr(ref, :uses_mrope)
  end

  @spec uses_xdrope_dim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def uses_xdrope_dim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :uses_xdrope_dim)
  end

  @spec video_pruning_rate(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def video_pruning_rate(ref) do
    SnakeBridge.Runtime.get_attr(ref, :video_pruning_rate)
  end
end
