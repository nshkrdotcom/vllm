# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: KVTransferConfig

defmodule Vllm.Config.KVTransferConfig do
  @moduledoc """
  Configuration for distributed KV cache transfer.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "KVTransferConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `KVTransferConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Python method `KVTransferConfig.get_from_extra_config`.

  ## Parameters

  - `key` (term())
  - `default` (term())

  ## Returns

  - `term()`
  """
  @spec get_from_extra_config(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_from_extra_config(ref, key, default, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_from_extra_config, [key, default], opts)
  end

  @spec enable_permute_local_kv(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_permute_local_kv(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_permute_local_kv)
  end

  @spec engine_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def engine_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :engine_id)
  end

  @spec is_kv_consumer(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_kv_consumer(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_kv_consumer)
  end

  @spec is_kv_producer(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_kv_producer(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_kv_producer)
  end

  @spec is_kv_transfer_instance(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_kv_transfer_instance(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_kv_transfer_instance)
  end

  @spec kv_buffer_device(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_buffer_device(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_buffer_device)
  end

  @spec kv_buffer_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_buffer_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_buffer_size)
  end

  @spec kv_connector(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_connector(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_connector)
  end

  @spec kv_connector_module_path(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_connector_module_path(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_connector_module_path)
  end

  @spec kv_ip(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_ip(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_ip)
  end

  @spec kv_load_failure_policy(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_load_failure_policy(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_load_failure_policy)
  end

  @spec kv_parallel_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_parallel_size)
  end

  @spec kv_port(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_port(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_port)
  end

  @spec kv_rank(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_rank(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_rank)
  end

  @spec kv_role(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_role(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_role)
  end
end
