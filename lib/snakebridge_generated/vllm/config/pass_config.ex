# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: PassConfig

defmodule Vllm.Config.PassConfig do
  @moduledoc """
  Configuration for custom Inductor passes.

  This is separate from general `CompilationConfig` so that inductor passes
  don't all have access to full configuration - that would create a cycle as
  the `PassManager` is set as a property of config.

  You must pass PassConfig to VLLMConfig constructor via the CompilationConfig
  constructor. VLLMConfig's post_init does further initialization.
  If used outside of the VLLMConfig, some fields may be left in an
  improper state.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "PassConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `PassConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Skip validation if the value is `None` when initialisation is delayed.

  ## Parameters

  - `value` (term())
  - `handler` (term())

  ## Returns

  - `term()`
  """
  @spec _skip_none_validation(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _skip_none_validation(ref, value, handler, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_skip_none_validation, [value, handler], opts)
  end

  @doc """
  Produces a hash unique to the pass configuration.

  Any new fields that affect compilation should be added to the hash.
  Any future fields that don't affect compilation should be excluded.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Python method `PassConfig.default_fi_allreduce_fusion_max_size_mb`.

  ## Returns

  - `%{optional(integer()) => float()}`
  """
  @spec default_fi_allreduce_fusion_max_size_mb(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, %{optional(integer()) => float()}} | {:error, Snakepit.Error.t()}
  def default_fi_allreduce_fusion_max_size_mb(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :default_fi_allreduce_fusion_max_size_mb, [], opts)
  end

  @doc """
  Returns the max communication size in bytes for flashinfer

  allreduce fusion for the given world size. Returns None if world size
  is not supported by configs as it's not supported by flashinfer.

  ## Parameters

  - `world_size` (integer())

  ## Returns

  - `term()`
  """
  @spec flashinfer_max_size(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def flashinfer_max_size(ref, world_size, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :flashinfer_max_size, [world_size], opts)
  end

  @spec eliminate_noops(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def eliminate_noops(ref) do
    SnakeBridge.Runtime.get_attr(ref, :eliminate_noops)
  end

  @spec enable_qk_norm_rope_fusion(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_qk_norm_rope_fusion(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_qk_norm_rope_fusion)
  end

  @spec enable_sp(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_sp(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_sp)
  end

  @spec fi_allreduce_fusion_max_size_mb(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def fi_allreduce_fusion_max_size_mb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fi_allreduce_fusion_max_size_mb)
  end

  @spec fuse_act_quant(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fuse_act_quant(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fuse_act_quant)
  end

  @spec fuse_allreduce_rms(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fuse_allreduce_rms(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fuse_allreduce_rms)
  end

  @spec fuse_attn_quant(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fuse_attn_quant(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fuse_attn_quant)
  end

  @spec fuse_gemm_comms(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fuse_gemm_comms(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fuse_gemm_comms)
  end

  @spec fuse_norm_quant(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def fuse_norm_quant(ref) do
    SnakeBridge.Runtime.get_attr(ref, :fuse_norm_quant)
  end
end
