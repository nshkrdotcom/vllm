# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: PoolerConfig

defmodule Vllm.Config.PoolerConfig do
  @moduledoc """
  Controls the behavior of output pooling in pooling models.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "PoolerConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `PoolerConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Python method `PoolerConfig.get_seq_pooling_type`.

  ## Returns

  - `term()`
  """
  @spec get_seq_pooling_type(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_seq_pooling_type(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_seq_pooling_type, [], opts)
  end

  @doc """
  Python method `PoolerConfig.get_tok_pooling_type`.

  ## Returns

  - `term()`
  """
  @spec get_tok_pooling_type(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def get_tok_pooling_type(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :get_tok_pooling_type, [], opts)
  end

  @spec activation(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def activation(ref) do
    SnakeBridge.Runtime.get_attr(ref, :activation)
  end

  @spec dimensions(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dimensions(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dimensions)
  end

  @spec enable_chunked_processing(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_chunked_processing(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_chunked_processing)
  end

  @spec logit_bias(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def logit_bias(ref) do
    SnakeBridge.Runtime.get_attr(ref, :logit_bias)
  end

  @spec max_embed_len(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_embed_len(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_embed_len)
  end

  @spec normalize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def normalize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :normalize)
  end

  @spec pooling_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def pooling_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :pooling_type)
  end

  @spec returned_token_ids(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def returned_token_ids(ref) do
    SnakeBridge.Runtime.get_attr(ref, :returned_token_ids)
  end

  @spec seq_pooling_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def seq_pooling_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :seq_pooling_type)
  end

  @spec softmax(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def softmax(ref) do
    SnakeBridge.Runtime.get_attr(ref, :softmax)
  end

  @spec step_tag_id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def step_tag_id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :step_tag_id)
  end

  @spec tok_pooling_type(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tok_pooling_type(ref) do
    SnakeBridge.Runtime.get_attr(ref, :tok_pooling_type)
  end

  @spec use_activation(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def use_activation(ref) do
    SnakeBridge.Runtime.get_attr(ref, :use_activation)
  end
end
