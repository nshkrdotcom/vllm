# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: SpeculativeConfig

defmodule Vllm.Config.SpeculativeConfig do
  @moduledoc """
  Configuration for speculative decoding.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "SpeculativeConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `SpeculativeConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Determine the max sequence len for the draft model. This is usually

  the draft_max_model_len, but may be the target_max_model_len if it is
  less than the draft_max_model_len, or may be speculative_max_model_len
  if it is specified.

  This is necessary so that sequences do not exceed the capacity of the
  draft model or the target model.

  speculative_max_model_len is mainly used for testing that sequences can
  skip speculation.

  ## Parameters

  - `speculative_max_model_len` (term())
  - `draft_max_model_len` (integer())
  - `target_max_model_len` (integer())

  ## Returns

  - `integer()`
  """
  @spec _maybe_override_draft_max_model_len(
          SnakeBridge.Ref.t(),
          term(),
          integer(),
          integer(),
          keyword()
        ) :: {:ok, integer()} | {:error, Snakepit.Error.t()}
  def _maybe_override_draft_max_model_len(
        ref,
        speculative_max_model_len,
        draft_max_model_len,
        target_max_model_len,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_maybe_override_draft_max_model_len,
      [speculative_max_model_len, draft_max_model_len, target_max_model_len],
      opts
    )
  end

  @doc """
  Python method `SpeculativeConfig._validate_suffix_decoding`.

  ## Returns

  - `term()`
  """
  @spec _validate_suffix_decoding(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_suffix_decoding(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_suffix_decoding, [], opts)
  end

  @doc """
  Verifies and adjusts the tensor parallel size for a draft model

  specified using speculative_draft_tensor_parallel_size.

  ## Parameters

  - `target_parallel_config` (term())
  - `speculative_draft_tensor_parallel_size` (term())
  - `draft_hf_config` (term())

  ## Returns

  - `integer()`
  """
  @spec _verify_and_get_draft_tp(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def _verify_and_get_draft_tp(
        ref,
        target_parallel_config,
        speculative_draft_tensor_parallel_size,
        draft_hf_config,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :_verify_and_get_draft_tp,
      [target_parallel_config, speculative_draft_tensor_parallel_size, draft_hf_config],
      opts
    )
  end

  @doc """
  Python method `SpeculativeConfig._verify_args`.

  ## Returns

  - `term()`
  """
  @spec _verify_args(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _verify_args(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_verify_args, [], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Create a parallel config for use by the draft worker.

  This is mostly a copy of the target parallel config, except the tp_size.

  ## Parameters

  - `target_parallel_config` (term())
  - `speculative_draft_tensor_parallel_size` (integer())

  ## Returns

  - `term()`
  """
  @spec create_draft_parallel_config(SnakeBridge.Ref.t(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def create_draft_parallel_config(
        ref,
        target_parallel_config,
        speculative_draft_tensor_parallel_size,
        opts \\ []
      ) do
    SnakeBridge.Runtime.call_method(
      ref,
      :create_draft_parallel_config,
      [target_parallel_config, speculative_draft_tensor_parallel_size],
      opts
    )
  end

  @doc """
  Python method `SpeculativeConfig.hf_config_override`.

  ## Parameters

  - `hf_config` (term())

  ## Returns

  - `term()`
  """
  @spec hf_config_override(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def hf_config_override(ref, hf_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :hf_config_override, [hf_config], opts)
  end

  @doc """
  Python method `SpeculativeConfig.use_eagle`.

  ## Returns

  - `boolean()`
  """
  @spec use_eagle(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def use_eagle(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :use_eagle, [], opts)
  end

  @spec code_revision(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def code_revision(ref) do
    SnakeBridge.Runtime.get_attr(ref, :code_revision)
  end

  @spec disable_by_batch_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_by_batch_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_by_batch_size)
  end

  @spec disable_padded_drafter_batch(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def disable_padded_drafter_batch(ref) do
    SnakeBridge.Runtime.get_attr(ref, :disable_padded_drafter_batch)
  end

  @spec draft_model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def draft_model_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :draft_model_config)
  end

  @spec draft_parallel_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def draft_parallel_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :draft_parallel_config)
  end

  @spec draft_tensor_parallel_size(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def draft_tensor_parallel_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :draft_tensor_parallel_size)
  end

  @spec enforce_eager(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enforce_eager(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enforce_eager)
  end

  @spec max_model_len(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max_model_len(ref) do
    SnakeBridge.Runtime.get_attr(ref, :max_model_len)
  end

  @spec method(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def method(ref) do
    SnakeBridge.Runtime.get_attr(ref, :method)
  end

  @spec model(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def model(ref) do
    SnakeBridge.Runtime.get_attr(ref, :model)
  end

  @spec num_speculative_tokens(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_speculative_tokens(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_speculative_tokens)
  end

  @spec prompt_lookup_max(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def prompt_lookup_max(ref) do
    SnakeBridge.Runtime.get_attr(ref, :prompt_lookup_max)
  end

  @spec prompt_lookup_min(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def prompt_lookup_min(ref) do
    SnakeBridge.Runtime.get_attr(ref, :prompt_lookup_min)
  end

  @spec quantization(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def quantization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :quantization)
  end

  @spec revision(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def revision(ref) do
    SnakeBridge.Runtime.get_attr(ref, :revision)
  end

  @spec speculative_token_tree(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def speculative_token_tree(ref) do
    SnakeBridge.Runtime.get_attr(ref, :speculative_token_tree)
  end

  @spec suffix_decoding_max_cached_requests(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffix_decoding_max_cached_requests(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffix_decoding_max_cached_requests)
  end

  @spec suffix_decoding_max_spec_factor(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffix_decoding_max_spec_factor(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffix_decoding_max_spec_factor)
  end

  @spec suffix_decoding_max_tree_depth(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffix_decoding_max_tree_depth(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffix_decoding_max_tree_depth)
  end

  @spec suffix_decoding_min_token_prob(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffix_decoding_min_token_prob(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffix_decoding_min_token_prob)
  end

  @spec target_model_config(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def target_model_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :target_model_config)
  end

  @spec target_parallel_config(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def target_parallel_config(ref) do
    SnakeBridge.Runtime.get_attr(ref, :target_parallel_config)
  end
end
