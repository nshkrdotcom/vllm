# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: CacheConfig

defmodule Vllm.Config.CacheConfig do
  @moduledoc """
  Configuration for the KV cache.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "CacheConfig"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Constructs `CacheConfig`.

  ## Parameters

  - `dataclass_self__` (term())
  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(dataclass_self__, args, kwargs, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [dataclass_self__, args, kwargs], opts)
  end

  @doc """
  Python method `CacheConfig._validate_cache_dtype`.

  ## Parameters

  - `cache_dtype` (term())

  ## Returns

  - `term()`
  """
  @spec _validate_cache_dtype(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _validate_cache_dtype(ref, cache_dtype, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_validate_cache_dtype, [cache_dtype], opts)
  end

  @doc """
  WARNING: Whenever a new field is added to this config,

  ensure that it is included in the factors list if
  it affects the computation graph.

  Provide a hash that uniquely identifies all the configs
  that affect the structure of the computation
  graph from input ids/embeddings to the final hidden states,
  excluding anything before input ids/embeddings and after
  the final hidden states.

  ## Returns

  - `String.t()`
  """
  @spec compute_hash(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, String.t()} | {:error, Snakepit.Error.t()}
  def compute_hash(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :compute_hash, [], opts)
  end

  @doc """
  Python method `CacheConfig.metrics_info`.

  ## Returns

  - `term()`
  """
  @spec metrics_info(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def metrics_info(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :metrics_info, [], opts)
  end

  @doc """
  Python method `CacheConfig.verify_with_parallel_config`.

  ## Parameters

  - `parallel_config` (term())

  ## Returns

  - `nil`
  """
  @spec verify_with_parallel_config(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, nil} | {:error, Snakepit.Error.t()}
  def verify_with_parallel_config(ref, parallel_config, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :verify_with_parallel_config, [parallel_config], opts)
  end

  @spec block_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def block_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :block_size)
  end

  @spec cache_dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cache_dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cache_dtype)
  end

  @spec calculate_kv_scales(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def calculate_kv_scales(ref) do
    SnakeBridge.Runtime.get_attr(ref, :calculate_kv_scales)
  end

  @spec cpu_kvcache_space_bytes(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cpu_kvcache_space_bytes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cpu_kvcache_space_bytes)
  end

  @spec cpu_offload_gb(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cpu_offload_gb(ref) do
    SnakeBridge.Runtime.get_attr(ref, :cpu_offload_gb)
  end

  @spec enable_prefix_caching(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def enable_prefix_caching(ref) do
    SnakeBridge.Runtime.get_attr(ref, :enable_prefix_caching)
  end

  @spec gpu_memory_utilization(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def gpu_memory_utilization(ref) do
    SnakeBridge.Runtime.get_attr(ref, :gpu_memory_utilization)
  end

  @spec is_attention_free(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_attention_free(ref) do
    SnakeBridge.Runtime.get_attr(ref, :is_attention_free)
  end

  @spec kv_cache_memory_bytes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_cache_memory_bytes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_cache_memory_bytes)
  end

  @spec kv_offloading_backend(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_offloading_backend(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_offloading_backend)
  end

  @spec kv_offloading_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_offloading_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_offloading_size)
  end

  @spec kv_sharing_fast_prefill(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def kv_sharing_fast_prefill(ref) do
    SnakeBridge.Runtime.get_attr(ref, :kv_sharing_fast_prefill)
  end

  @spec mamba_block_size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mamba_block_size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mamba_block_size)
  end

  @spec mamba_cache_dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mamba_cache_dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mamba_cache_dtype)
  end

  @spec mamba_page_size_padded(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mamba_page_size_padded(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mamba_page_size_padded)
  end

  @spec mamba_ssm_cache_dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def mamba_ssm_cache_dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mamba_ssm_cache_dtype)
  end

  @spec num_cpu_blocks(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_cpu_blocks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_cpu_blocks)
  end

  @spec num_gpu_blocks(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_gpu_blocks(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_gpu_blocks)
  end

  @spec num_gpu_blocks_override(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def num_gpu_blocks_override(ref) do
    SnakeBridge.Runtime.get_attr(ref, :num_gpu_blocks_override)
  end

  @spec prefix_caching_hash_algo(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def prefix_caching_hash_algo(ref) do
    SnakeBridge.Runtime.get_attr(ref, :prefix_caching_hash_algo)
  end

  @spec sliding_window(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def sliding_window(ref) do
    SnakeBridge.Runtime.get_attr(ref, :sliding_window)
  end

  @spec swap_space(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def swap_space(ref) do
    SnakeBridge.Runtime.get_attr(ref, :swap_space)
  end
end
