# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.config
# Python class: CompilationMode

defmodule Vllm.Config.CompilationMode do
  @moduledoc """
  The compilation approach used for torch.compile-based compilation of the

  model.
  """
  def __snakebridge_python_name__, do: "vllm.config"
  def __snakebridge_python_class__, do: "CompilationMode"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwds` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Return a pair of integers, whose ratio is equal to the original int.

  The ratio is in lowest terms and has a positive denominator.

  >>> (10).as_integer_ratio()
  (10, 1)
  >>> (-10).as_integer_ratio()
  (-10, 1)
  >>> (0).as_integer_ratio()
  (0, 1)

  ## Returns

  - `term()`
  """
  @spec as_integer_ratio(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def as_integer_ratio(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :as_integer_ratio, [], opts)
  end

  @doc """
  Number of ones in the binary representation of the absolute value of self.

  Also known as the population count.

  >>> bin(13)
  '0b1101'
  >>> (13).bit_count()
  3

  ## Returns

  - `term()`
  """
  @spec bit_count(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bit_count(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :bit_count, [], opts)
  end

  @doc """
  Number of bits necessary to represent self in binary.

  >>> bin(37)
  '0b100101'
  >>> (37).bit_length()
  6

  ## Returns

  - `term()`
  """
  @spec bit_length(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def bit_length(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :bit_length, [], opts)
  end

  @doc """
  Returns self, the complex conjugate of any int.

  ## Returns

  - `term()`
  """
  @spec conjugate(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec conjugate(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def conjugate(ref) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [], [])
  end

  def conjugate(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [], opts)
  end

  def conjugate(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1], [])
  end

  def conjugate(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1], opts)
  end

  def conjugate(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2], [])
  end

  def conjugate(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2], opts)
  end

  def conjugate(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3], [])
  end

  def conjugate(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3], opts)
  end

  def conjugate(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4], [])
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4], opts)
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :conjugate,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :conjugate,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :conjugate,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def conjugate(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :conjugate,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder` as the byte order value.  Default is to use 'big'.
  signed
    Indicates whether two's complement is used to represent the integer.

  ## Parameters

  - `bytes` (term())
  - `byteorder` (term() default: 'big')
  - `signed` (term() keyword-only default: False)

  ## Returns

  - `term()`
  """
  @spec from_bytes(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_bytes(ref, bytes, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :from_bytes, [bytes] ++ List.wrap(args), opts)
  end

  @doc """
  Returns True. Exists for duck type compatibility with float.is_integer.

  ## Returns

  - `term()`
  """
  @spec is_integer(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_integer(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_integer, [], opts)
  end

  @doc """
  Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.  Default
    is length 1.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder` as the byte order value.  Default is to use 'big'.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.

  ## Parameters

  - `length` (term() default: 1)
  - `byteorder` (term() default: 'big')
  - `signed` (term() keyword-only default: False)

  ## Returns

  - `term()`
  """
  @spec to_bytes(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def to_bytes(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :to_bytes, [] ++ List.wrap(args), opts)
  end

  @spec dynamo_trace_once(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dynamo_trace_once(ref) do
    SnakeBridge.Runtime.get_attr(ref, :DYNAMO_TRACE_ONCE)
  end

  @spec none(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def none(ref) do
    SnakeBridge.Runtime.get_attr(ref, :NONE)
  end

  @spec stock_torch_compile(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stock_torch_compile(ref) do
    SnakeBridge.Runtime.get_attr(ref, :STOCK_TORCH_COMPILE)
  end

  @spec vllm_compile(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def vllm_compile(ref) do
    SnakeBridge.Runtime.get_attr(ref, :VLLM_COMPILE)
  end

  @spec denominator(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def denominator(ref) do
    SnakeBridge.Runtime.get_attr(ref, :denominator)
  end

  @spec imag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def imag(ref) do
    SnakeBridge.Runtime.get_attr(ref, :imag)
  end

  @spec numerator(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def numerator(ref) do
    SnakeBridge.Runtime.get_attr(ref, :numerator)
  end

  @spec real(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def real(ref) do
    SnakeBridge.Runtime.get_attr(ref, :real)
  end
end
