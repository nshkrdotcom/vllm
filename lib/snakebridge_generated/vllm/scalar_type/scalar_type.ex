# Generated by SnakeBridge v0.16.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: vllm 0.14.0
# Python module: vllm.scalar_type
# Python class: ScalarType

defmodule Vllm.ScalarType do
  @moduledoc """
  ScalarType can represent a wide range of floating point and integer

  types, in particular it can be used to represent sub-byte data types
  (something that torch.dtype currently does not support). It is also
  capable of  representing types with a bias, i.e.:
    `stored_value = value + bias`,
  this is useful for quantized types (e.g. standard GPTQ 4bit uses a bias
  of 8). The implementation for this class can be found in
  csrc/core/scalar_type.hpp, these type signatures should be kept in sync
  with that file.
  """
  def __snakebridge_python_name__, do: "vllm.scalar_type"
  def __snakebridge_python_class__, do: "ScalarType"
  def __snakebridge_library__, do: "vllm"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `exponent` (integer())
  - `mantissa` (integer())
  - `signed` (boolean())
  - `bias` (integer())
  - `finite_values_only` (boolean() default: False)
  - `nan_repr` (Vllm.ScalarType.NanRepr.t() default: <NanRepr.IEEE_754: 1>)
  """
  @spec new(integer(), integer(), boolean(), integer(), list(term()), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(exponent, mantissa, signed, bias, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)

    SnakeBridge.Runtime.call_class(
      __MODULE__,
      :__init__,
      [exponent, mantissa, signed, bias] ++ List.wrap(args),
      opts
    )
  end

  @doc """
  Python method `ScalarType._floating_point_max`.

  ## Returns

  - `float()`
  """
  @spec _floating_point_max(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, float()} | {:error, Snakepit.Error.t()}
  def _floating_point_max(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_floating_point_max, [], opts)
  end

  @doc """
  Python method `ScalarType._floating_point_max_int`.

  ## Returns

  - `integer()`
  """
  @spec _floating_point_max_int(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, integer()} | {:error, Snakepit.Error.t()}
  def _floating_point_max_int(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_floating_point_max_int, [], opts)
  end

  @doc """
  Python method `ScalarType._raw_max`.

  ## Returns

  - `term()`
  """
  @spec _raw_max(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _raw_max(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_raw_max, [], opts)
  end

  @doc """
  Python method `ScalarType._raw_min`.

  ## Returns

  - `term()`
  """
  @spec _raw_min(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _raw_min(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_raw_min, [], opts)
  end

  @doc """
  Create a non-standard floating point type

  (i.e. does not follow IEEE 754 conventions).

  ## Parameters

  - `exponent` (integer())
  - `mantissa` (integer())
  - `finite_values_only` (boolean())
  - `nan_repr` (Vllm.ScalarType.NanRepr.t())

  ## Returns

  - `Vllm.ScalarType.t()`
  """
  @spec float_(
          SnakeBridge.Ref.t(),
          integer(),
          integer(),
          boolean(),
          Vllm.ScalarType.NanRepr.t(),
          keyword()
        ) :: {:ok, Vllm.ScalarType.t()} | {:error, Snakepit.Error.t()}
  def float_(ref, exponent, mantissa, finite_values_only, nan_repr, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      ref,
      :float_,
      [exponent, mantissa, finite_values_only, nan_repr],
      opts
    )
  end

  @doc """
  Create a standard floating point type

  (i.e. follows IEEE 754 conventions).

  ## Parameters

  - `exponent` (integer())
  - `mantissa` (integer())

  ## Returns

  - `Vllm.ScalarType.t()`
  """
  @spec float_ieee754(SnakeBridge.Ref.t(), integer(), integer(), keyword()) ::
          {:ok, Vllm.ScalarType.t()} | {:error, Snakepit.Error.t()}
  def float_ieee754(ref, exponent, mantissa, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, "float_IEEE754", [exponent, mantissa], opts)
  end

  @doc """
  Python method `ScalarType.from_id`.

  ## Parameters

  - `scalar_type_id` (integer())

  ## Returns

  - `term()`
  """
  @spec from_id(SnakeBridge.Ref.t(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def from_id(ref, scalar_type_id, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :from_id, [scalar_type_id], opts)
  end

  @doc """
  If the type has a non-zero bias

  ## Returns

  - `boolean()`
  """
  @spec has_bias(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def has_bias(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :has_bias, [], opts)
  end

  @doc """
  If the type is floating point and supports infinity

  ## Returns

  - `boolean()`
  """
  @spec has_infs(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def has_infs(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :has_infs, [], opts)
  end

  @doc """
  Python method `ScalarType.has_nans`.

  ## Returns

  - `boolean()`
  """
  @spec has_nans(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def has_nans(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :has_nans, [], opts)
  end

  @doc """
  Create a signed integer scalar type (size_bits includes sign-bit).

  ## Parameters

  - `size_bits` (integer())
  - `bias` (term())

  ## Returns

  - `Vllm.ScalarType.t()`
  """
  @spec int_(SnakeBridge.Ref.t(), integer(), term(), keyword()) ::
          {:ok, Vllm.ScalarType.t()} | {:error, Snakepit.Error.t()}
  def int_(ref, size_bits, bias, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :int_, [size_bits, bias], opts)
  end

  @doc """
  If the type is a floating point type

  ## Returns

  - `boolean()`
  """
  @spec is_floating_point(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_floating_point(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_floating_point, [], opts)
  end

  @doc """
  If the type is a floating point type that follows IEEE 754

  conventions

  ## Returns

  - `boolean()`
  """
  @spec is_ieee_754(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_ieee_754(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_ieee_754, [], opts)
  end

  @doc """
  If the type is an integer type

  ## Returns

  - `boolean()`
  """
  @spec is_integer(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_integer(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_integer, [], opts)
  end

  @doc """
  If the type is signed (i.e. has a sign bit), same as `signed`

  added for consistency with:
  https://pytorch.org/docs/stable/generated/torch.Tensor.is_signed.html

  ## Returns

  - `boolean()`
  """
  @spec is_signed(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def is_signed(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_signed, [], opts)
  end

  @doc """
  Max representable value for this scalar type.

  (accounting for bias if there is one)

  ## Returns

  - `term()`
  """
  @spec max(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def max(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :max, [], opts)
  end

  @doc """
  Min representable value for this scalar type.

  (accounting for bias if there is one)

  ## Returns

  - `term()`
  """
  @spec min(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def min(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :min, [], opts)
  end

  @doc """
  Create an unsigned integer scalar type.

  ## Parameters

  - `size_bits` (integer())
  - `bias` (term())

  ## Returns

  - `Vllm.ScalarType.t()`
  """
  @spec uint(SnakeBridge.Ref.t(), integer(), term(), keyword()) ::
          {:ok, Vllm.ScalarType.t()} | {:error, Snakepit.Error.t()}
  def uint(ref, size_bits, bias, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :uint, [size_bits, bias], opts)
  end

  @spec _finite_values_only(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _finite_values_only(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_finite_values_only)
  end

  @spec id(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def id(ref) do
    SnakeBridge.Runtime.get_attr(ref, :id)
  end

  @spec nan_repr(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nan_repr(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nan_repr)
  end

  @spec size_bits(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def size_bits(ref) do
    SnakeBridge.Runtime.get_attr(ref, :size_bits)
  end
end
